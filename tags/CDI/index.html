<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Next Presso | </title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/stylesheets/asciidoctor.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css"><link rel="stylesheet" href="/stylesheets/styles.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script><script type="text/javascript" src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script><!--[if lt IE 9]><script type="text/javascript" src="//html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]--><script>hljs.initHighlightingOnLoad(); </script></head><body><div class="container"><div class="row"><div class="col-md-12"><div class="bannerhome"><div class="container"><div class="row"><div class="col-md-12 maintitle"><h1>Next Presso (CDI, Java EE and friends)</h1></div></div></div></div><nav class="navbar navbar-default navbar-static-top" role="navigation"><div class="container-fluid"><div class="navbar-header"><button class="navbar-toggle collasped" type="button" data-toggle="collapse" data-target=".navbar-collapse"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="http://www.next-presso.com"><i class="fa fa-home fa-fw"></i> Home </a></div></div></nav><script type="text/javascript">var indexOfSharp = window.location.pathname.indexOf('#');
var pathname = indexOfSharp > 0 ? window.location.pathname.substring(0, indexOfSharp) : window.location.pathname;
var selector = "body > .container > .row > .col-md-12 > .navbar > .container-fluid > .navbar-collapse a[href='http://www.next-presso.com" + pathname + "']";
$(selector).closest("li").addClass("active");</script></div></div><div class="row"><div class="col-md-12"><div class="row"><div class="col-md-9"><div class="posts"><article class="post"><div class="panel panel-primary"><div class="panel-body"><h1><a href="/2014/06/you-think-you-know-everything-about-cdi-events-think-again/">You think you know everything about CDI events… Think again!</a></h1><div class="meta"><strong>Posted by <span class="authors">Antoine Sabot-Durand</span> on <span class="date">Jun 10, 2014</span> |  <a href="http://www.next-presso.com/2014/06/you-think-you-know-everything-about-cdi-events-think-again/#disqus_thread">Comments</a> </strong></div><div class="content"><div id="preamble">
<div class="sectionbody">
<div class="imageblock" style="float: left">
<div class="content">
<img src="/images/posts/2014/Event-bus.jpg" alt="Event bus" width="310">
</div>
<div class="title">Event Bus may surprise you</div>
</div>
<div class="paragraph">
<p>CDI events are one of the shiniest feature in the CDI specification. They are a easy to understand and use and are a straight forward implementation of the Observer Design Pattern. To sum up they add more decoupling to the Dependency Injection by allowing notification of unknown target at development time (great to develop framework). Yet, documentation about event is often misleading and contains inaccurate information, probably due to the fact that the specification was wrong before we corrected it for CDI 1.2 release ;). This post is the opportunity to update or clarify your knowledge  about how events work in CDI 1.0  and 1.1+ and what could come in CDI 2.0.
If you want to “play” with event you can checkout my Github project EventsTest to use it as a sandbox.</p>
</div>
<div class="paragraph">
<p>If you are familiar with events you can directly go to the more advanced or less know features</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="back-to-the-basics"><a class="anchor" href="#back-to-the-basics"></a>Back to the basics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before going further, let’s introduce basic concepts around CDI events.</p>
</div>
<div class="sect2">
<h3 id="what-s-an-event"><a class="anchor" href="#what-s-an-event"></a>What’s an event?</h3>
<div class="paragraph">
<p>CDI events are defined by 2 things :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A java object (the event object)</p>
</li>
<li>
<p>A set of qualifiers (annotations having the meta annotation @Qualifier)
The event Object could be of any Java type and don’t have to be CDI related (try to avoid using bean instance as event object, it’s confusing and if the bean scope is not @Dependent could bring issues related to bean lifecycle). Qualifiers are the same used to define CDI Bean or injection point. They can have members or not. And their members value are part of the qualifier definition or not (if they have the @NonBinding annotation).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="how-to-fire-an-event"><a class="anchor" href="#how-to-fire-an-event"></a>How to fire an event?</h3>
<div class="paragraph">
<p>The most universal way to fire an event is to use the BeanManager.fireEvent(Object event,Annotation&#8230;&#8203; qualifiers) method. BeanManger is directly accessible in CDI bean by injecting it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>@Inject
BeanManager beanManager;

public void doSomething() {
  beanManager.fireEvent(new Payload());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Outside CDI you can alway retrieve it by JNDI (by looking up for “java:comp/BeanManager” name)or more easily in CDI 1.1+ via CDI class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>BeanManager beanManager = CDI.current().getBeanManager();

public void doSomething() {
  beanManager.fireEvent(new Payload());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In CDI bean, it is more common and natural to use the Event&lt;T&gt; interface to get possibility to fire an event like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>@Inject
Event&lt;Payload&gt; payloadEvent;

public void doSomething() {
  payloadEvent.fire(new Payload());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Event&lt;T&gt;</code> interface is an helper to fire event whose type is totally CDI agnostic and thus doesn’t include a way of being fired. To make a gun fire analogy, In the previous example, see payloadEvent as the bullet case while the bullet is the instance of Payload you gave as parameter of the fire() method.</p>
</div>
</div>
<div class="sect2">
<h3 id="observing-events"><a class="anchor" href="#observing-events"></a>Observing events</h3>
<div class="paragraph">
<p>To observe an event you’ll have to add an observer method in an enable bean of your application. An observer method is a method whose first parameter has the @Observes annotation. The type of the parameter with @Observes will be used to resolve target observer when an event is fired as we’ll see later. So:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>public void listenToPayload(@Observes Payload event) {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will be triggered (if the method is in an active bean) for all events whose type are Payload or a super type of Payload. Off course qualifier may be added to the observer to restrict event triggering:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>public void listenToPayload(@Observes @Qualified Payload event) {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The observers resolution occurs at runtime when an event is fired. All the observers that match the event will be triggered by the CDI container. Note that the observer method may have other beans as parameters. They will be injected by the container before calling the method :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>public void listenToPayload(@Observes Payload event, PayloadService service) {
  ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="features-you-may-have-missed-regarding-cdi-events"><a class="anchor" href="#features-you-may-have-missed-regarding-cdi-events"></a>Features you may have missed regarding CDI events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following CDI events feature are less known or badly documented.</p>
</div>
<div class="sect2">
<h3 id="no-type-erasure-for-event-type"><a class="anchor" href="#no-type-erasure-for-event-type"></a>No type erasure for event type</h3>
<div class="paragraph">
<p>It’s not an hidden feature but more something implicit in CDI than can be missed. As CDI is a type centric specification (I always sigh when I see and injection point with a @Name qualifier), it does a better job than standard Java regarding parameterized type.</p>
</div>
<div class="paragraph">
<p>For instance take these 2 observer methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>public void processNumberList(@Observes List&lt;Number&gt; event) {
  ...
}

public void processIntegerList(@Observes List&lt;Integer&gt; event) {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The container will make the distinction between both when resolving observer depending of the parameterized type of the event.  And in CDI 1.1+ (wildcards are not allowed in observer event parameter in CDI 1.0) if you declare the following observers :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>public void processIntegerList(@Observes List&lt;? super Integer&gt; event) {
...
}

public void processNumberList(@Observes List&lt;? extends Number&gt; event) {
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both will be called if your event type is List&lt;Integer&gt; or List&lt;Number&gt;. Although the first observer will fit for add elements to the list while the second will be used to fetch elements from the list.</p>
</div>
<div class="paragraph">
<p>Remember that if wildcards are allowed in observer in CDI 1.1+ if they aren’t in Event injection point.</p>
</div>
</div>
<div class="sect2">
<h3 id="qualifiers-don-t-work-with-event-as-they-work-with-beans"><a class="anchor" href="#qualifiers-don-t-work-with-event-as-they-work-with-beans"></a>Qualifiers don’t work with event as they work with beans</h3>
<div class="paragraph">
<p>That’s an important point that was very badly explained in the spec before CDI 1.2. Developers often assume that Event&lt;&gt; and Instance&lt;&gt; have quite similar way of functioning regarding qualifiers, that’s a big mistake. But let’s start with the most important here :</p>
</div>
<div class="paragraph">
<p>An observer matches an event if its type is in the event types set and if the observer has a subset of the qualifier of the event.</p>
</div>
<div class="paragraph">
<p>Better check this with a piece of code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>/**
 * Qualifier with binding member
 */
@Qualifier
@Target({TYPE, METHOD, PARAMETER, FIELD})
@Retention(RUNTIME)
@Documented
public @interface Qualified {
    String value() default "";
}

public class EventTestService {

    @Inject
    @Qualified("strong")
    Event&lt;Payload&gt; payLoadEvent;

    public void fireEvent() {
      payloadEvent.fire(new Payload());
    }

    public void processUnqualifiedPayload(@Observes Payload event) {}

    public void processQualifiedPayload(@Observes @Qualified("strong") Payload event) {}

    public void processUnqualifiedObject(@Observes Object event) {}

    public void processQualifiedObject(@Observes @Qualified("strong") Object event) {}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yes, all the 4 declared observers will be called by the container when the event is fired. Useful to know that ;).</p>
</div>
<div class="paragraph">
<p>So <code>@Any</code> qualifier is totally useless on events or observers</p>
</div>
<div class="paragraph">
<p>The spec requires that all created events should have the <code>@Any</code> automatically added, but as we just saw <code>@Any</code> has the same behavior in event that @Default qualifier (no qualifier), so prefer using no qualifier instead of using @Any, it’ll be less confusing.</p>
</div>
<div class="paragraph">
<p><code>Event&lt;&gt;</code> is here to build events not filter them</p>
</div>
<div class="paragraph">
<p>Again <code>Event</code> looks like <code>Instance</code> but is very different. While <code>Instance</code> is a tool to lookup for beans, <code>Event</code> is a tool to build an event from an object and qualifiers.
So keep in mind that when you use <code>Event.select(Annotation... qualifiers)</code> you are adding qualifier to the event you’ll be firing.
For instance :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>public class EventTestService {

    @Inject
    @MyQualifier
    Event&lt;Payload&gt; payLoadEvent;

    public void fireEvent() {
      payloadEvent.select(new QualifiedLiteral()).fire(new Payload());
    }
}

public class QualifiedLiteral extends AnnotationLiteral&lt;Qualified&gt; implements Qualified {

    private String value="";

    public QualifiedLiteral(String value) {
        this.value = value;
    }

    public QualifiedLiteral() {
        this("");
    }

    public String value() {
        return value;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will add the <code>@Qualified</code> qualifier to the event before firing it. So the final event will have <code>@MyQualifier @Qualified("")</code> qualifiers.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced-event-features"><a class="anchor" href="#advanced-event-features"></a>Advanced Event Features</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="conditional-observer-methods"><a class="anchor" href="#conditional-observer-methods"></a>Conditional Observer methods</h3>
<div class="paragraph">
<p>As we saw, observer methods have to be in a bean to be registered by the container. If the bean containing the observer has a different scope than @Dependent we may want to control if the call to the observer should trigger bean instantiation.
You can do that with the receive member of @Observes annotation which can take the enum values javax.enterprise.event.Reception.ALWAYS (by default) or javax.enterprise.event.Reception.IF_EXISTS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>@RequestScoped
public class EventTestService {

    // will always be called (bean my be instantiated for this call)
    public void processQualifiedPayload(@Observes(receive=ALWAYS) Type1 event) {}

    // will be called only if the bean already exists in Request scope
    public void processUnqualifiedPayload(@Observes(receive=IF_EXISTS) Type2 event) {}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember that IF_EXISTS cannot be used in a bean having @Dependent scope since the bean cannot exists before observer is called. If you do the mistake the container will remember you that at startup.</p>
</div>
</div>
<div class="sect2">
<h3 id="transactional-observer-methods"><a class="anchor" href="#transactional-observer-methods"></a>Transactional observer methods</h3>
<div class="paragraph">
<p>Transactional observer methods are observer methods which receive event notifications during the before or after completion phase of the transaction in which the event was fired. If no transaction is in progress when the event is fired, they are notified at the same time as other observers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A before completion observer method is called during the before completion phase of the transaction.</p>
</li>
<li>
<p>An after completion observer method is called during the after completion phase of the transaction.</p>
</li>
<li>
<p>An after success observer method is called during the after completion phase of the transaction, only when the transaction completes successfully.</p>
</li>
<li>
<p>An after failure observer method is called during the after completion phase of the transaction, only when the transaction fails.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can specify the transaction phase of the observer call with the during member of the <code>@Observes</code> annotation.
The enumeration <code>javax.enterprise.event.TransactionPhase</code> identifies the kind of transactional observer method the enum values are:</p>
</div>
<div class="paragraph">
<p>IN_PROGRESS: default value
BEFORE_COMPLETION
AFTER_COMPLETION
AFTER_FAILURE
AFTER_SUCCESS
For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>@RequestScoped
public class EventTestService {

    // is called when the event is fired
    public void processCustomerUpdateRequest(@Observes(during=IN_PROGRESS) @Updated customer cust) {}

    // is called by the same event fired than previous observer but only after the trnsaction complete successufully
    public void processCustomerUpdated(@Observes(during=AFTER_SUCCESS) @Updated customer cust) {}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the transaction observer mechanism is the only way to differ and order some observer right now.</p>
</div>
</div>
<div class="sect2">
<h3 id="built-in-events-linked-to-scope-lifecycle-cdi-1-1"><a class="anchor" href="#built-in-events-linked-to-scope-lifecycle-cdi-1-1"></a>Built-in events linked to scope lifecycle (CDI 1.1+)</h3>
<div class="paragraph">
<p>Since CDI 1.1, the container fire events when context are created and destroyed, thanks to the provided @Intialized and @Destroyed qualifiers.
If your application is deployed in a servlet container, the event payload correspond to the servlet scope object corresponding to the initialized or destroyed CDI scope. Otherwise payload will be java.lang.object
You can observe these event in your application like this (if it’s deployed in a servlet container) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>public void processApplicationScopedInit(@Observes @Initialized(ApplicationScoped.class) ServletContext payload) {}

public void processApplicationScopedDestroyed(@Observes @Destroyed(ApplicationScoped.class) ServletContext payload) {}

public void processSessionScopedInit(@Observes @Initialized(SessionScoped.class) HttpSession payload) {}

public void processSessionScopedDestroyed(@Observes @Destroyed(SessionScoped.class) HttpSession payload) {}

public void processRequestScopedInit(@Observes @Initialized(RequestScoped.class) ServletRequest payload) {}

public void processRequestScopedDestroyed(@Observes @Destroyed(RequestScoped.class) ServletRequest payload) {}

public void processConversationScopedInit(@Observes @Initialized(ConversationScoped.class) ServletRequest payload) {}

public void processConversationScopedDestroyed(@Observes @Destroyed(ConversationScoped.class) ServletRequest payload) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specification encourage third party extension to do the same for custom context.</p>
</div>
</div>
<div class="sect2">
<h3 id="events-metadata-cdi-1-1"><a class="anchor" href="#events-metadata-cdi-1-1"></a>Events Metadata (CDI 1.1+)</h3>
<div class="paragraph">
<p>Version 1.1 of the spec introduced EventMetadata interface. It allows an observer to get all the metadata about an event.
You get the EventMetadata by adding it to the observer parameters :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>public void processPayload(@Observes Payload event, EventMetadata meta) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The EventMetadata contains the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>getQualifiers() returns the set of qualifiers with which the event was fired.</p>
</li>
<li>
<p>getInjectionPoint() returns the InjectionPoint from which this event payload was fired, or null if it was fired from BeanManager.fireEvent(…).</p>
</li>
<li>
<p>getType() returns the type representing runtime class of the event object with type variables resolved.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This bring a solution to add more fine-grained filtering on observer execution depending on actual metadata of the triggered event</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="events-limitation"><a class="anchor" href="#events-limitation"></a>Events limitation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Right now, CDI events have two big limitation out of the box</p>
</div>
<div class="sect2">
<h3 id="events-are-only-synchronous"><a class="anchor" href="#events-are-only-synchronous"></a>Events are only synchronous</h3>
<div class="paragraph">
<p>Out of the box events are synchronous: method firing an event has to wait the end of all observers invocation before executing instruction after event firing. So no fire and forget option and off course no callback approach.
The obvious solution if you need asynchronous event approach is to use an EJB method as an observer and annotate it @Asynchronous. Other options exists but you need to create a CDI portable extension and play with threads. I’ll try to explore that in a future post.</p>
</div>
</div>
<div class="sect2">
<h3 id="observers-have-no-orders"><a class="anchor" href="#observers-have-no-orders"></a>Observers have no orders</h3>
<div class="paragraph">
<p>Yes, there’s no out of the box solution to guarantee order of observers execution. The only tiny exception is using transaction phase to do so but it’s very limited. Perhaps a CDI extension could help us here again. I’ll try to explore this approach in a future post.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pattern-and-tips-with-events"><a class="anchor" href="#pattern-and-tips-with-events"></a>Pattern and tips with events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Putting all the knowledge we have now on event and other CDI stuff we can figure out some interesting pattern for our developement.</p>
</div>
<div class="sect2">
<h3 id="the-plugin-pattern"><a class="anchor" href="#the-plugin-pattern"></a>The plugin Pattern</h3>
<div class="paragraph">
<p>We saw that CDI event data is totally free. You can choose any object (again avoid no dependent bean) to fire an event and this object will be received as a playlod by each observer matching the event type and qualifier.
An other interesting fact is that this payload is mutable and can be modified by its observers. Following this idea, observers can become a way to enrich a given object with new data. We can use this approach to seamlessly enhance content by adding a CDI archive to an existing application.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-catch-them-all-pattern"><a class="anchor" href="#the-catch-them-all-pattern"></a>The catch them all pattern</h3>
<div class="paragraph">
<p>Need to observe all fired event and have their info (for logging purpose for instance), you only have to observe Object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>public void processPayload(@Observes Object event, EventMetadata meta) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>EventMetadata will even help you to know in which bean the event was fired. A nice way to build a bridge with a messaging service (did I say JMS? ;) )</p>
</div>
</div>
<div class="sect2">
<h3 id="don-t-forget-interceptors-and-decorators"><a class="anchor" href="#don-t-forget-interceptors-and-decorators"></a>Don’t forget Interceptors and Decorators</h3>
<div class="paragraph">
<p>While it’s forbidden to declare observer in decorators or interceptors, you can still fire event from them. So they can be used to enhance existing bean and add event triggering to them without touching their code.
A nice way to add event notification only when needed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="future-for-cdi-events"><a class="anchor" href="#future-for-cdi-events"></a>Future for CDI events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have a lot of idea in CDI 2.0 regarding event enhancement. Off course adding observer priority and asynchronous treatment are on the top of the list. On asynchronous event we could even think of adding callback method support based on java.lang.invoke package.
More ambitious ideas are floating around like giving a range to events making them cross the War or Ear barrer and spread across the server or the cluster. That could lead us to provide an event bus at the server level and help java EE to adopt new application architectures in the future  EE versions.</p>
</div>
</div>
</div></div><div class="footer"><a href="/2014/06/you-think-you-know-everything-about-cdi-events-think-again/"> Permalink</a> <a href="http://www.next-presso.com/2014/06/you-think-you-know-everything-about-cdi-events-think-again/#disqus_thread">Comments</a> </div></div></div></article><article class="post"><div class="panel panel-primary"><div class="panel-body"><h1><a href="/2014/03/forward-cdi-2-0/">Forward CDI 2.0</a></h1><div class="meta"><strong>Posted by <span class="authors">Antoine Sabot-Durand</span> on <span class="date">Mar 15, 2014</span> |  <a href="http://www.next-presso.com/2014/03/forward-cdi-2-0/#disqus_thread">Comments</a> </strong></div><div class="content"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><span class="image" style="float: left"><img src="/images/posts/2014/back-to-the-future.jpg" alt="back to the future" width="200"></span>
CDI is probably one of most overlooked specification in Java EE, yet when version 1.0 was released 4 years ago it was presented as “Java EE extension point”. Technically it’s the case, but for all kind of reason some JSR didn&#8217;t adopt CDI totally to provide a more consistent experience in Java EE. Today the IT world is moving fast and after long years of heavy memory and process solution we’re going back to resource optimization with mobile or embedded platform. As CDI can leave outside Java EE, it could play an interesting role in this new approach. But before that it should evolve to be ready for this new challenge (and continue to pursue its growing role in Java EE as well) In this post I’ll try to share my ideas on how  CDI should evolve to meet it future rendez-vous. So I’ll start by exposing the new feature I’d like to see in CDI before exploring a more modular architecture for the spec to make it scalable from Raspberry  Pi to Huge cluster solutions.</p>
</div>
<div class="paragraph">
<p><em>Disclaimer : Since I’ll be leading CDI 2.0 specification (with Pete Muir) it’s important to stress that this post is not an official announcement about the content of the CDI 2.0 specification. It’s only my thought and doesn’t engage CDI Expert Group or Red Hat.</em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="new-features-i-d-like-to-have"><a class="anchor" href="#new-features-i-d-like-to-have"></a>New features I’d like to have</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some of these features are already in the Expert Group pipeline, some were deferred during CDI 1.1 for CDI 2.0, some are standardisation of third party development (mainly <a href="http://deltaspike.apache.org" target="_blank">Apache Deltaspike</a>) and some are totally new. Anyway, most of these point are important to help third party project or JSR to get the best of CDI.</p>
</div>
<div class="sect2">
<h3 id="java-se-bootstrapping"><a class="anchor" href="#java-se-bootstrapping"></a>Java SE Bootstrapping</h3>
<div class="paragraph">
<p>I don’t need to insist on this point. Today each implementation provide a way to bootstrap CDI in Java SE or in a poor server (Servlet only) environnement. Apache Deltaspike has a generic solution to do it. So it’s time that the CDI spec integrates this to be officially available in Java SE.</p>
</div>
</div>
<div class="sect2">
<h3 id="container-hot-swap"><a class="anchor" href="#container-hot-swap"></a>Container hot swap</h3>
<div class="paragraph">
<p>Strong typed injection is great, but CDI is too strict on this in my opinion. To support dynamic JVM language, we should be able to trigger a BeanManager restart with runtime added bean. this could be done for instance by providing API for bootstrapping a new CDI container with augmented content. If the boot went well have more step to duplicate status and existing instance in the new container and garbage the old one. In case of error we could keep the existing BeanManager. A costly but very useful feature for advanced tools or app that could provide specific enhancement system (CMS, e-commerce platform, etc…).</p>
</div>
</div>
<div class="sect2">
<h3 id="cdi-lite"><a class="anchor" href="#cdi-lite"></a>CDI lite</h3>
<div class="paragraph">
<p>As said in my introduction, there’s a shared wish to bring CDI to embedded devices like Raspberry pi, Arduino, Lego Mindstorms or Android. Today the massive uses of proxies in implementations prevent us to go in that direction.</p>
</div>
<div class="paragraph">
<p>Java Proxies were very useful in the 2000’s, but now they begin to be old fashioned and brings a lot of problem (huge stack trace, JVM optimization, High resource consumption, etc…). Right now CDI spec take for granted that proxies will be used in implementations.</p>
</div>
<div class="paragraph">
<p>For this reason, it could be a good solution to provide a subset of CDI specification with less magic and less weight. Let’s call it “CDI Lite” (like EJB Lite that were introduced in Java EE 6). This CDI subset would keep all the DI stuff but would probably get rid of all the Context part as well as Interceptor and Decorator.</p>
</div>
<div class="paragraph">
<p>But there are others tracks that could be explored to make CDI lighter without removing some of its features.</p>
</div>
</div>
<div class="sect2">
<h3 id="bye-bye-proxy-hello-annotation-processing-and-invokedynamic"><a class="anchor" href="#bye-bye-proxy-hello-annotation-processing-and-invokedynamic"></a>Bye bye Proxy, hello Annotation Processing and InvokeDynamic</h3>
<div class="paragraph">
<p>This other way is to find solution to replace proxies by something else in CDI implementations. Right now we have two candidates :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Annotation Processing : process Annotation at compile time to produce the “magic” injection/injected/decorated code in a static way like it’s done in <a href="http://google.github.io/dagger/">Dagger</a>.</p>
</li>
<li>
<p>InvokeDynamic : Runtime linking could provide a proxy-like behavior with less drawbacks and probably more performances. Regarding this second approach I started to do some researches and hope provide a proof of concept soon.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="xml-config-file"><a class="anchor" href="#xml-config-file"></a>XML config file</h3>
<div class="paragraph">
<p>It’s time to provide this feature in the spec. There use to be extensions out there that provide this feature, but this is a core feature allowing bean registering and annotation overloading at deploy time and it should be in the spec. If CDI could become more and more present in the other spec, it could also be the beginning of a universal Java EE config file format !</p>
</div>
<div class="paragraph">
<p>Today, some framework like Apache Camel cannot use CDI because there is no config solution. Providing a solution on that point would ease CDI adoption.</p>
</div>
</div>
<div class="sect2">
<h3 id="asynchronous-event-action"><a class="anchor" href="#asynchronous-event-action"></a>Asynchronous event / action</h3>
<div class="paragraph">
<p>At the vert.x and node.js era we definitely should support asynchronous treatment (and let’s dream : call back). This could be done By using concurrency spec. We would provide a way to support asynchronous call without using EJB and asynchronous event by adding a boolean asynchronous field in @Observes and, optionally, a handle on a callback</p>
</div>
</div>
<div class="sect2">
<h3 id="support-of-startup"><a class="anchor" href="#support-of-startup"></a>Support of @Startup</h3>
<div class="paragraph">
<p>An easy feature to add : provide a way to have a CDI bean automatically instantiated after the initialization phase like we already have in EJB.</p>
</div>
<div class="paragraph">
<p>It’s a very common request by developers and it’s not very hard to provide.</p>
</div>
</div>
<div class="sect2">
<h3 id="portable-extension-spi-promotion-usage-simplification"><a class="anchor" href="#portable-extension-spi-promotion-usage-simplification"></a>Portable Extension SPI promotion / usage simplification</h3>
<div class="imageblock" style="float: right">
<div class="content">
<img src="/images/posts/2014/CDI-Lifecycle.png" alt="CDI Lifecycle" width="450">
</div>
<div class="title">CDI 1.1 container initialization and Lifecycle</div>
</div>
<div class="paragraph">
<p>Portable Extension is, in my opinion, the best feature in CDI. Off course IoC, events or context management are great but they weren’t new when introduced in CDI 1.0.</p>
</div>
<div class="paragraph">
<p>Portable extension is a complete CDI innovation, that added to Java EE DNA the possibility to be naturally extended without using proprietary tricks.</p>
</div>
<div class="paragraph">
<p>In my opinion it’s a pity that Portable Extension were not more promoted (CDI acronym doesn’t include any idea of their existence for instance) and were placed at the end of our specification document since a lot of projects or other specification could benefit from it.</p>
</div>
<div class="paragraph">
<p>My analyze is that this lack of communication is linked to the bunch of more or less complexe concepts (like the container initialization events shown in the right side schema) to understand before being able to deep dive into extension development. We should probably provide a higher simplified layer to get started with basic task on extension. Don’t misunderstand me, the existing mechanism is great and should be kept (with probably some enhancement) but we should provide helpers to ease extension creation. These helper could be :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Standardization of Deltaspike <code>AnnotatedTypeBuilder</code> and <code>BeanBuilder</code> to ease new Beans creation</p>
</li>
<li>
<p>Helpers on introspection tools regarding types or annotation manipulation</p>
</li>
<li>
<p>Easier way to create new scopes or extend existing ones. We encourage other spec to extend lifecycle of existing scopes (like @RequestScoped for Websocket) but it’s nearly impossible to do it without going at the implementation level.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We should also bring a special attention to the first events (until AfterTypeDiscovery) in this initialization process, since they are CDI agnostic dealing only with type and annotation metadata modification. These could become part of a future Java EE configuration system.</p>
</div>
</div>
<div class="sect2">
<h3 id="ordering-event-execution"><a class="anchor" href="#ordering-event-execution"></a>Ordering event execution</h3>
<div class="paragraph">
<p>So in CDI 1.1 decorator and interceptor are ordered thanks to @Priority. What about ordering events ? Using @Priority on @Observes doesn&#8217;t seem a good idea since this annotation comes from the interceptor package, but we could add an int priority field in @Observes.</p>
</div>
</div>
<div class="sect2">
<h3 id="no-more-segregation-for-producers-and-custom-beans"><a class="anchor" href="#no-more-segregation-for-producers-and-custom-beans"></a>No more segregation for Producers and Custom beans</h3>
<div class="paragraph">
<p>Why produced bean or custom bean should be CDI second class citizen? I want to be able to decorate or use interceptor on my produced beans or at least have APIs that allow me to add this features to my produced beans.</p>
</div>
</div>
<div class="sect2">
<h3 id="event-scoping-from-package-to-server-wide"><a class="anchor" href="#event-scoping-from-package-to-server-wide"></a>Event scoping from package to server wide</h3>
<div class="paragraph">
<p>Having the CDI event bus at a higher level in Java EE would allow scoping our event. Soone could decide if the event should stay in the current application, be restricted to the current module (in an EAR) even the current package or on the other side be broadcasted to all app listening to it.</p>
</div>
</div>
<div class="sect2">
<h3 id="transient-injection"><a class="anchor" href="#transient-injection"></a>Transient injection</h3>
<div class="paragraph">
<p>When injecting dependent bean in a longer living bean, this injection is done once when the longer bean is instantiated. There are use cases (I’ve got one in Agorava) where I want my dependent bean to be re-injected each times it’s accessed. Today I have to write :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>@Inject Instance&lt;MyBean&gt; myBeanInstances;
public Mybean getMyBean() { return myBeanInstances.get(); }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tomorrow I’d like to write this :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>@Inject @Transient MyBean myBean;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s mainly syntaxic sugar but make the code more easy to write and readable. We probably could find other example here of code simplification.</p>
</div>
</div>
<div class="sect2">
<h3 id="have-a-more-fluent-programmatic-lookup"><a class="anchor" href="#have-a-more-fluent-programmatic-lookup"></a>Have a more fluent programmatic lookup</h3>
<div class="paragraph">
<p>The <code>Instance&lt;T&gt;</code> interface and the programmatic lookup are incredibly useful, but it could be very cumbersome to use especially when we have to deal with Qualifiers.</p>
</div>
<div class="paragraph">
<p>This could be eased by providing tools to generate qualifier literals  with Java 8 Type Annotations for instance.  And why not a query DSL ?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>myBeanInstance.restrictedTo(BeanImp.class).withQualifier(new @MyQualifier("Binding") AnnotationLiteral&lt;&gt;(), new @MyOtherQualifier AnnotationLiteral&lt;&gt;()).select();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wouldn&#8217;t it be more user friendly ?</p>
</div>
</div>
<div class="sect2">
<h3 id="monitoring-facility"><a class="anchor" href="#monitoring-facility"></a>Monitoring facility</h3>
<div class="paragraph">
<p>Remember the great debug page in Seam 2 ? I’d like to have the same things or tools to easily build the same feature to monitor my beans and my scope. CDI does a lot of Magic and it could be nice to have tools to see all its trick and the cost of beans, context and other interceptor we deployed</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="give-me-more-modularity-a-new-architecture-for-cdi-and-java-ee"><a class="anchor" href="#give-me-more-modularity-a-new-architecture-for-cdi-and-java-ee"></a>Give me more modularity : a new architecture for CDI (and Java EE ?)</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image" style="float: left"><img src="/images/posts/2014/CDI-Next-Architecture.png" alt="CDI Next Architecture" width="400"></span></p>
</div>
<div class="paragraph">
<p>A lot of JSR complained that CDI spec is too monolithic and that implementations are too heavy comparing to theirs (they don’t want to depend on something bigger). This and the lack of standard Java SE bootstrapping, are probably the 2 mains objection to go for a deep CDI integration in some spec. So we should provide a more modular approach while keeping the possibility to gather all the modules and have a consistent stack that we could use outside Java EE. In my ideal world the different JSR / Modules would be :</p>
</div>
<div class="sect2">
<h3 id="container"><a class="anchor" href="#container"></a>Container</h3>
<div class="paragraph">
<p>This module store all the beans defined in the application. Providing as a standalone module brings the following features :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provides a minimum api/impl for a client app that rely on JNDI to get Beans</p>
</li>
<li>
<p>Provides the possibility to add plugins to the container to support new kind of components (Servlet, JPA Entity, Guice or Spring beans for instance)</p>
</li>
<li>
<p>Prepare the CDI container to be the future universal Java EE container that we’re waiting for</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="event-bus"><a class="anchor" href="#event-bus"></a>Event bus</h3>
<div class="paragraph">
<p>Events and observer pattern are great features of CDI spec. But they would be more useful if spec could use them without having to depend on all CDI.</p>
</div>
<div class="paragraph">
<p>We could imagine a new Java EE specification or a CDI module based on CDI event API to provide Java EE wide eventing model. We could imagine an API only relying on half a dozen classes (more if we add asynchronous treatment, ordering and event scoping) hat would do the Job.</p>
</div>
</div>
<div class="sect2">
<h3 id="component-scanning-extension-engine"><a class="anchor" href="#component-scanning-extension-engine"></a>Component Scanning &amp; Extension engine</h3>
<div class="paragraph">
<p>Today each specification does class scanning at boot time. In general the app server provides a way to group this scanning process in a proprietary way. By standardizing the scanning phase events and the meta-data manipulated during this scanning phase we could provide a consistent experience and a standard way to extend Java EE. CDI already provides most of this feature with its initialization mechanism which allow to “observe” all wished existing classes in deployment and modify meta-data of these classes (i.e. annotations) .</p>
</div>
<div class="paragraph">
<p>Imagine what you could do if the ProcessAnnotatedType event could be catch at the server level and allow you to put a “veto” on a given servlet or on a group of JPA entities? This feature lead us on the single container and the single configuration file path. A feature dreamt by a lot of developers.</p>
</div>
</div>
<div class="sect2">
<h3 id="basic-di"><a class="anchor" href="#basic-di"></a>Basic DI</h3>
<div class="paragraph">
<p>This module would include all API related to simple injection (only pseudo-scope). So all <code>@Inject</code>, <code>@Qualifier</code>, <code>Instance&lt;T&gt;</code>, <code>@Producer</code>, <code>InjectionPoint</code> and other Reflection stuff will be gathered in a light API. Probably what I called “CDI lite” in my previous part.</p>
</div>
</div>
<div class="sect2">
<h3 id="context-management"><a class="anchor" href="#context-management"></a>Context Management</h3>
<div class="paragraph">
<p>Context is a nice feature of CDI but as everybody don’t need it, it should be put in a optional API package. This part will deal with all the normal scope context and complex life cycles.</p>
</div>
</div>
<div class="sect2">
<h3 id="interceptor-decorator"><a class="anchor" href="#interceptor-decorator"></a>Interceptor &amp; Decorator</h3>
<div class="paragraph">
<p>Today interceptors already have their own JSR. Adding decorator to the JSR would complete the interceptor JSR.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion-cdi-needs-you"><a class="anchor" href="#conclusion-cdi-needs-you"></a>Conclusion : CDI needs you!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So, here’s my personal CDI wish list. You probably have yours (we collected your 3 CDI 2 wishes in december / january, and we intend to use them. If you didn’t send them, feel free to add them in comment of this article). I don’t know if all these point are good ideas (just read the comment to make your opinion). I don’t know if they are all doable (probably not). What I know is that we’ll need all help we can have to work on the future CDI 2.0. So if you want to be part of this adventure, stay tuned on <a href="http://cdi-spec.org" target="_blank">CDI official website</a>, <a href="http://twitter.com/cdispec" target="_blank">@cdispec</a> twitter account (or <a href="http://twitter.com/antoine_sd" target="_blank">mine</a>) and this blog and give us your feedback on <a href="https://lists.jboss.org/mailman/listinfo/cdi-dev" target="_blank">CDI ML</a> or CDI IRC channel (#jsr346 on freenode). The coming months will be decisive regarding CDI (and Java EE) future.</p>
</div>
</div>
</div></div><div class="footer"><a href="/2014/03/forward-cdi-2-0/"> Permalink</a> <a href="http://www.next-presso.com/2014/03/forward-cdi-2-0/#disqus_thread">Comments</a> </div></div></div></article></div>
            <script type="text/javascript">
            var disqus_shortname = 'nextpresso';
            (function () {
              var s = document.createElement('script'); s.async = true;
              s.src = '//' + disqus_shortname + '.disqus.com/count.js';
              (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
            }());
            </script>
          <div class="visible-xs"><ul class="pager"><li class="previous disabled"><a href="#"> Previous</a></li><li class="disabled"><a href="#">1 of 1</a></li><li class="next disabled"><a href="#"> Next</a></li></ul></div><div class="hidden-xs"><ul class="pager"><li class="disabled"><a href="#"> First</a></li><li class="disabled"><a href="#"> Previous</a></li><li class="active"><a href="#">1 of 1</a></li><li class="disabled"><a href="#"> Next</a></li><li class="disabled"><a href="#"> Last</a></li></ul></div></div><div class="col-md-3"><div class="follow-scroll hidden-xs"><div style="margin-bottom:20px;text-align:center;"><a class="btn btn-default" href="http://www.next-presso.com/news.atom">Subscribe RSS</a></div><div class="panel panel-default"><div class="panel-heading"><h3 class="panel-title">Tag Cloud</h3></div><div class="panel-footer" style="text-align:justify;"><div class="tag-cloud">
  <span class="tag tag-0">
    <a href="http://www.next-presso.com/tags/CDI/">CDI</a>
  </span>
</div>
</div></div><a class="twitter-timeline" data-widget-id="666631820319019009" href="https://twitter.com/antoine_sd"> Tweets by @antoine_sd</a><script type="text/javascript">!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div><div class="visible-xs"><div style="margin-bottom:20px;text-align:center;"><a class="btn btn-default" href="http://www.next-presso.com/news.atom">Subscribe RSS</a></div><div class="panel panel-default"><div class="panel-heading"><h3 class="panel-title">Tag Cloud</h3></div><div class="panel-footer" style="text-align:justify;"><div class="tag-cloud">
  <span class="tag tag-0">
    <a href="http://www.next-presso.com/tags/CDI/">CDI</a>
  </span>
</div>
</div></div></div></div></div></div></div></div><hr><footer></footer><script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount','UA-5919317-1']);
_gaq.push(['_trackPageview']);
(function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body></html>