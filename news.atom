<?xml version="1.0" encoding="utf-8" ?>
<feed xml:lang="en-US" xmlns="http://www.w3.org/2005/Atom">
  <id>http://www.next-presso.com/</id>
  <title>Next Presso</title>
  <updated>2017-02-07T16:51:38+01:00</updated>
  <link href="http://www.next-presso.com/news.atom" rel="self" type="application/atom+xml" />
  <link href="http://www.next-presso.com/" rel="alternate" type="text/html" />
  <entry>
    <id>http://www.next-presso.com/2017/02/nobody-expects-the-cdi-portable-extensions.html</id>
    <title>Nobody expects the CDI portable extensions</title>
    <updated>2017-02-07T16:51:38+01:00</updated>
    <published>2017-02-06T00:00:00+00:00</published>
    <link href="http://www.next-presso.com/2017/02/nobody-expects-the-cdi-portable-extensions.html" rel="alternate" type="text/html" />
    <category term="CDI"></category>
    <category term="SPI"></category>
    <category term="Extension"></category>
    <summary>
      Portable extensions are probably the coolest feature of CDI.
      
      
      Unfortunately, this gem is a bit hidden in the spec and some developers totally missed it while others may wrongly think that using extension is too complicated.
      
      
      With this article, I&#8217;ll try to show that everybody can use extension in their work as it can be used to provide simple feature or advanced integration mechanism.
      
      
      But first things first, let&#8217;s answer the basic question "why would you need to develop a portable extension".
      
      
      What can I do with an extension
      
      
      At boot time CDI scans most of the class in the classpath to create its configuration...
    </summary>
    <content type="html">
      &lt;div class=&quot;imageblock&quot; style=&quot;float: right&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/posts/2017/rainbow_lego.jpg&quot; alt=&quot;rainbow lego&quot; width=&quot;285&quot; /&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Portable extensions are probably the coolest feature of CDI.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Unfortunately, this gem is a bit hidden in the spec and some developers totally missed it while others may wrongly think that using extension is too complicated.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;With this article, I’ll try to show that everybody can use extension in their work as it can be used to provide simple feature or advanced integration mechanism.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;But first things first, let’s answer the basic question &quot;why would you need to develop a portable extension&quot;.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;what-can-i-do-with-an-extension&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#what-can-i-do-with-an-extension&quot;&gt;&lt;/a&gt;What can I do with an extension&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;At boot time CDI scans most of the class in the classpath to create its configuration and the bean graph.
      The configuration and meta data that are created at this moment are created from static content (class file) and may need some more dynamic content.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;That’s where portable extension gets in.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A CDI portable extension allows you to hook on the CDI scanning process which occurs at boot time and modify or add information to the meta data created by the CDI container.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;That includes add Beans, remove classes from set of type that should become bean, add producers, observers and most of the &lt;a href=&quot;http://www.next-presso.com/2016/02/cdi-the-spi-who-loved-me/&quot;&gt;SPI elements&lt;/a&gt; that exist in CDI.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;So to make short, extensions are how developers can configure CDI and override default behaviour created from reading the classes.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;getting-started-with-cdi-extension&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#getting-started-with-cdi-extension&quot;&gt;&lt;/a&gt;Getting started with CDI extension&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI portable extensions are based on &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html&quot; target=&quot;_blank&quot;&gt;Java SE service-provider&lt;/a&gt;.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Service interface is &lt;code&gt;javax.enterprise.inject.spi.Extension&lt;/code&gt;, so to add an extension you’ll need to create a class implementing &lt;code&gt;javax.enterprise.inject.spi.Extension&lt;/code&gt; interface and add this class qualified name to the &lt;code&gt;META-INF/services/javax.enterprise.inject.spi.Extension&lt;/code&gt; service provider text file.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Extension feature is defined by adding observers on specific lifecycle event of the CDI container.
      At boot time, the CDI container will use service provider mechanism to discover all extensions and register these observers.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This approach allows you to hook on internal lifecycle steps of the container and modify their outcome.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Let’s check what are these step.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;extension-step-by-step&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#extension-step-by-step&quot;&gt;&lt;/a&gt;Extension step by step&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;To understand how to work with extensions, we can start by splitting container lifecycle in 4 Big steps:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/broaderlifecycle.svg&quot; alt=&quot;The major steps of the CDI container lifecycle&quot; width=&quot;889&quot; height=&quot;60&quot; /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;title&quot;&gt;The major steps of the CDI container lifecycle&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Eah of these step (except &quot;Application running&quot;) contains one or more events for which you can define one or more observers in your extension to hook on CDI elements discovery and meta data building.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Let’s focus on each of these steps and describe the events that you can use in each one.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Some examples given below will use new features coming from CDI 2.0.
      I’ll explain how same result can be obtained in CDI 1.2.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;types-discovery&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#types-discovery&quot;&gt;&lt;/a&gt;Types discovery&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Type discovery can be illustrated like this&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/typesdiscovery.svg&quot; alt=&quot;Types discovery&quot; width=&quot;413&quot; height=&quot;507&quot; /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;title&quot;&gt;Types discovery&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;admonitionblock note&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td class=&quot;icon&quot;&gt;
      &lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
      &lt;/td&gt;
      &lt;td class=&quot;content&quot;&gt;
      In this schema (and next ones), yellow boxes are the in which an extension can observes an event and perform actions, grey ones are simplification of internal container behaviour.
      &lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The goal of this step is to create a set of &lt;code&gt;AnnotatedType&lt;/code&gt; which will be candidate to become beans.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Ths set can be filled explicitly in a &lt;code&gt;BeforeTypeDiscovery&lt;/code&gt; or &lt;code&gt;AfterDiscovery&lt;/code&gt; observers&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It is also filled automatically by the container class scanning process on which developer can place a hook to alter the discovered by using a &lt;code&gt;ProcessAnnotatedType&lt;/code&gt; observer.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Let’s see in detail how all this work.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;adding-types-before-scanning-code-beforebeandiscovery-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#adding-types-before-scanning-code-beforebeandiscovery-code-event&quot;&gt;&lt;/a&gt;Adding types before scanning (&lt;code&gt;BeforeBeanDiscovery&lt;/code&gt; event)&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Before CDI container start automatic types scan on the class path, it fires the BeforeBeanDiscovery event.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Observing this events allows addition of a specific type to the set of discovered types or addition of specific CDI annotations like qualifier, stereotype or interceptor binding.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface BeforeBeanDiscovery {
        void addQualifier(Class&amp;lt;? extends Annotation&amp;gt; qualifier); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
        void addQualifier(AnnotatedType&amp;lt;? extends Annotation&amp;gt; qualifier); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
        void addScope(Class&amp;lt;? extends Annotation&amp;gt; scopeType, boolean normal, boolean passivating); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
        void addStereotype(Class&amp;lt;? extends Annotation&amp;gt; stereotype, Annotation... stereotypeDef); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
        void addInterceptorBinding(AnnotatedType&amp;lt;? extends Annotation&amp;gt; bindingType); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
        void addInterceptorBinding(Class&amp;lt;? extends Annotation&amp;gt; bindingType, Annotation... bindingTypeDef); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
        void addAnnotatedType(AnnotatedType&amp;lt;?&amp;gt; type, String id); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
      
        /* New methods in CDI 2.0 */
        &amp;lt;T&amp;gt; AnnotatedTypeConfigurator&amp;lt;T&amp;gt; addAnnotatedType(Class&amp;lt;T&amp;gt; type, String id); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
        &amp;lt;T extends Annotation&amp;gt; AnnotatedTypeConfigurator&amp;lt;T&amp;gt; configureQualifier(Class&amp;lt;T&amp;gt; qualifier); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
        &amp;lt;T extends Annotation&amp;gt; AnnotatedTypeConfigurator&amp;lt;T&amp;gt; configureInterceptorBinding(Class&amp;lt;T&amp;gt; bt); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Add a new qualifier with an &lt;code&gt;Annotation&lt;/code&gt;, an &lt;code&gt;AnnotatedType&lt;/code&gt; or by using the CDI 2.0 &lt;code&gt;AnnotatedTypeConfigurator&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Add a new scope &lt;code&gt;Annotation&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Define a new Stereotype by giving its &lt;code&gt;Annotation&lt;/code&gt; and the &lt;code&gt;Annotations&lt;/code&gt; collection it stands for&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Add a new interceptor binding with an &lt;code&gt;Annotation&lt;/code&gt; and its meta annotations, an &lt;code&gt;AnnotatedType&lt;/code&gt; or by using the CDI 2.0 &lt;code&gt;AnnotatedTypeConfigurator&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Add a new &lt;code&gt;AnnotatedType&lt;/code&gt; from a custom &lt;code&gt;AnnotatedType&lt;/code&gt; or by using the CDI 2.0 &lt;code&gt;AnnotatedTypeConfigurator&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The following example illustrate usage of this event.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MetricsExtension implements Extension { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      
          public void addMetricAsQual(@Observes BeforeBeanDiscovery bbd) { &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
              bbd.addQualifier(Metric.class); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;defining the extension (remember to also add class FQN to &lt;code&gt;META-INF/services/javax.enterprise.inject.spi.Extension&lt;/code&gt; text file&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;An observer for the &lt;code&gt;BeforeBeanDiscovery&lt;/code&gt; lifecycle event&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Declaring an annotation from a 3rd party non-CDI framework as a qualifier&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The example above is a piece of the &lt;a href=&quot;https://github.com/astefanutti/metrics-cdi&quot; target=&quot;_blank&quot;&gt;Dropwizard Metrics CDI integration extension&lt;/a&gt;.
      It declares a standard annotation (&lt;code&gt;@Metrics&lt;/code&gt;) as a CDI qualifier.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;You can also transform a non-CDI class to have it discovered as a managed bean by the container:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MyLegacyFrameworkService { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      
          private Configurator config;
      
          public MyLegacyFrameworkService(Configurator config) {
              this.config = config;
          }
      }
      
      ...
      
      public class LegacyIntegrationExtension implements Extension {
      
          public void addLegacyServiceAsBean(@Observes BeforeBeanDiscovery bbd) {
              bbd.addAnnotatedType(MyLegacyFrameworkService.class,MyLegacyFrameworkService.class.getName()) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
                      .add(ApplicationScoped.Literal.INSTANCE) &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
                      .filterConstructors(c -&amp;gt; c.getParameters().size() == 1)
                      .findFirst().get().add(InjectLiteral.INSTANCE); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
          }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;class from a legacy framework that we want to integrate into CDI programming model without changing its code&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;using an &lt;code&gt;AnnotatedTypeConfigurator&lt;/code&gt; (new in CDI 2.0) based on the &lt;code&gt;MyLegacyFrameworkService&lt;/code&gt; class&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;adding &lt;code&gt;@ApplicationScoped&lt;/code&gt; scope on the &lt;code&gt;AnnotatedTypeConfigurator&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;find the first constructor with one parameters and add the &lt;code&gt;@Inject&lt;/code&gt; on it&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The example above use new feature from CDI 2.0: the &lt;code&gt;AnnotatedTypeConfigurator&lt;/code&gt; returned by one of the &lt;code&gt;addAnnotatedType()&lt;/code&gt; methods of BeforeBeanDiscovery event.
      If you are in CDI 1.1 you can don the same but you’ll have to implement your own &lt;code&gt;AnnotatedType&lt;/code&gt; to do the same in more verbose way.
      to configure a new &lt;code&gt;AnnotatedType&lt;/code&gt; add a scope on it and an &lt;code&gt;@Inject&lt;/code&gt; annotation on one of its constructors.
      At the end of observer invocation, the container will automatically build the matching &lt;code&gt;AnnotatedType&lt;/code&gt; from this configurator and add it to the discovered type set.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;automatic-types-scanning-process&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#automatic-types-scanning-process&quot;&gt;&lt;/a&gt;Automatic types scanning process&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;After this first event, the container starts a process of type discovery in the application classpath.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This scanning can be configured differently for each bean archive (i.e. jar or module) in the classpath.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Each jar in the application path may (or may not) contain a &lt;code&gt;beans.xml&lt;/code&gt; file defining how types will be scanned by the CDI container for this bean archive.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Remember that CDI doesn’t provide a global configuration file so each of your bean archive (including the war container others bean archive) must define its discovery mode.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;There are 3 discovery mode:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;none&lt;/code&gt;: no type will be discovered for this bean archive&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;annotated&lt;/code&gt; (default mode): only class having specific annotations (&lt;a href=&quot;http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#bean_defining_annotations&quot;&gt;bean defining annotation&lt;/a&gt;^) will be discovered&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;all&lt;/code&gt;: all types will be discovered&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Discovery mode is inferred by analyzing the bean archive &lt;code&gt;beans.xml&lt;/code&gt; file&lt;/p&gt;
      &lt;/div&gt;
      &lt;table class=&quot;tableblock frame-all grid-all spread&quot;&gt;
      &lt;caption class=&quot;title&quot;&gt;Table 1. what is my discovery mode?&lt;/caption&gt;
      &lt;colgroup&gt;
      &lt;col style=&quot;width: 50%;&quot; /&gt;
      &lt;col style=&quot;width: 50%;&quot; /&gt;
      &lt;/colgroup&gt;
      &lt;thead&gt;
      &lt;tr&gt;
      &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;code&gt;beans.xml&lt;/code&gt; file state&lt;/th&gt;
      &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;discovery mode&lt;/th&gt;
      &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
      &lt;tr&gt;
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;No &lt;code&gt;beans.xml&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;annotated&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;empty &lt;code&gt;beans.xml&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;beans.xml&lt;/code&gt; using CDI 1.0 xsd&lt;/p&gt;&lt;/td&gt;
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;beans.xml&lt;/code&gt; using CDI 1.1 xsd&lt;/p&gt;&lt;/td&gt;
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;value of &lt;code&gt;bean-discovery-mode&lt;/code&gt; attribute&lt;/p&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/tbody&gt;
      &lt;/table&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;You can also fine grain type discovery by using &lt;a href=&quot;http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#exclude_filters&quot; target=&quot;_blank&quot;&gt;exclusion filters&lt;/a&gt;&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In CDI 2.0 when you are working on Java SE, jars without &lt;code&gt;beans.xml&lt;/code&gt; file are ignored by default.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;processannotatedtype-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#processannotatedtype-event&quot;&gt;&lt;/a&gt;ProcessAnnotatedType event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;After this scanning phase, the container creates an AnnotatedType and fire the ProcessAnnotatedType event for each type discovered (except for annotations).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface ProcessAnnotatedType&amp;lt;X&amp;gt; { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          AnnotatedType&amp;lt;X&amp;gt; getAnnotatedType(); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          void setAnnotatedType(AnnotatedType&amp;lt;X&amp;gt; type); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          void veto(); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
      
          /* New in CDI 2.0 */
          AnnotatedTypeConfigurator&amp;lt;X&amp;gt; configureAnnotatedType(); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;the event is a parameterized type allowing user to only process &lt;code&gt;AnnotatedType&lt;/code&gt; based on a given original type&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the current processed &lt;code&gt;AnnotatedType&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;replaces the processed &lt;code&gt;AnnotatedType&lt;/code&gt; by a new one defined by implementing &lt;code&gt;AnnotatedType&lt;/code&gt; interface or with the help of an &lt;code&gt;AnnotatedTypeConfigurator&lt;/code&gt; (new in CDI 2.0)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;remove the processed AnnotatedType from the set of discovered type: this type won’t become a bean&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is often use to override configuration on an existing type.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For instance the example below remove adds transactional annotation on the &lt;code&gt;StandardService&lt;/code&gt; class in a third party library.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class AddTranscationalToServiceExtension implements Extension {
      
          public void addTransactional(@Observes ProcessAnnotatedType&amp;lt;StandardService&amp;gt; pat) { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
              pat.configureAnnotatedType().add(new AnnotationLiteral&amp;lt;Transactional&amp;gt;(){});
          }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;observer will only be triggered for any &lt;code&gt;AnnotatedType&lt;/code&gt; based on &lt;code&gt;StandardService&lt;/code&gt; type&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It can also be used to veto type implementing an interface or having a specific annotation (thanks to the &lt;code&gt;@WithAnnotations&lt;/code&gt; filter).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class VetEntitiesExtension implements Extension {
      
          public void vetoEntities(@Observes @WithAnnotations(Entity.class) ProcessAnnotatedType&amp;lt;?&amp;gt; pat) { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
              pat.veto();
          }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;observer will be triggered for any &lt;code&gt;AnnotatedType&lt;/code&gt; based on any type having @Entity annotation&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This last example vetoes all JPA entities in the application to avoid using them as CDI beans.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;aftertypediscovery-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#aftertypediscovery-event&quot;&gt;&lt;/a&gt;AfterTypeDiscovery event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event closes the type discovery process&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface AfterTypeDiscovery {
          List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; getAlternatives(); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; getInterceptors(); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; getDecorators(); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          void addAnnotatedType(AnnotatedType&amp;lt;?&amp;gt; type, String id); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      
          /* New in CDI 2.0 */
          &amp;lt;T&amp;gt; AnnotatedTypeConfigurator&amp;lt;T&amp;gt; addAnnotatedType(Class&amp;lt;T&amp;gt; type, String id); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;these methods give you access to classes list discovered as possible alternatives beans, interceptors or decorators.
      You can use these inventory list to check everything you need is here or add a new class to them since these lists are mutable&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;as in &lt;code&gt;BeforeBeanDiscovery&lt;/code&gt; you can add a custom &lt;code&gt;AnnotatedType&lt;/code&gt; to the set of discovered &lt;code&gt;AnnotatedType&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The following extension checks that if &lt;code&gt;LastInterceptor&lt;/code&gt; class was discovered as an interceptor, this one will be invoked after all other interceptors.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class lastInteceptorExtension implements Extension {
      
      public void lastInterceptorCheck (@Observes AfterTypeDiscovery atd) {
              List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; interceptors = atd.getInterceptors();
              if(interceptors.indexOf(LastInterceptor.class) &amp;lt; interceptors.size()) {
                  interceptors.remove(LastInterceptor.class);
                  interceptors.add(LastInterceptor.class);
              }
          }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;beans-discovery-phase&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#beans-discovery-phase&quot;&gt;&lt;/a&gt;Beans discovery phase&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In this phase each discovered type is analyzed to check if they are eligible to become beans.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;If it’s the case a series of events are fired to allow modification of the future bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;If the bean was not vetoed by an extension, container launch producers and observers discovring processes.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;At the end of this phase, extension has opportunity to register custom beans or observers with the &lt;code&gt;AfterBeanDiscovery&lt;/code&gt; event.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The phase ends with the validation of all the element by the container and the &lt;code&gt;AfterDeploymentValidation&lt;/code&gt; event.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The following schema illustrates all the phase steps.
      While it could looks complicated at first, this process is rather easy to understand.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/beansdiscovery.svg&quot; alt=&quot;Beans discovery&quot; width=&quot;1217&quot; height=&quot;1606&quot; /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;title&quot;&gt;Beans discovery&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-processinjectionpoint-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-processinjectionpoint-code-event&quot;&gt;&lt;/a&gt;&lt;code&gt;ProcessInjectionPoint&lt;/code&gt; event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For each injection point encountered during this process, the container will fire a &lt;code&gt;ProcessInjectionPoint&lt;/code&gt; event.
      Injection points are fired for managed beans, producer methods and observer methods.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface ProcessInjectionPoint&amp;lt;T, X&amp;gt; { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          InjectionPoint getInjectionPoint(); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          void setInjectionPoint(InjectionPoint injectionPoint); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          void addDefinitionError(Throwable t); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
      
          /* New in CDI 2.0 */
          InjectionPointConfigurator configureInjectionPoint(); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;event is a parameterized type allowing observer to target a specific class &lt;code&gt;T&lt;/code&gt; containig the injection point or a specific injection point type &lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the &lt;code&gt;InjectionPoint&lt;/code&gt; processed by this event&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allow replacement of processed &lt;code&gt;InjectionPoint&lt;/code&gt; either by implementing custom &lt;code&gt;InjectionPoint&lt;/code&gt; or using and &lt;code&gt;InjectionPointConfigurator&lt;/code&gt; (new CDI in 2.0)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows observer to abort deployment by adding a definition error&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;An extension can observe this event for multiple reason.
      For instance it can be used to collect all types for a given qualifier and later create a bean to match these injection points&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ConvertExtension implements Extension {
      
          Set&amp;lt;Type&amp;gt; convertTypes = new HashSet();
      
          public void captureConfigTypes(@Observes ProcessInjectionPoint&amp;lt;?, ?&amp;gt; pip) {
              InjectionPoint ip = pip.getInjectionPoint();
              if (ip.getQualifiers().contains(Convert.Literal.Instance)) {
                  convertTypes.add(ip.getType());
              }
          }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The example above will create a set of types for all injection points in the application having the &lt;code&gt;@Convert&lt;/code&gt; qualifier.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Later it could use this collection to create custom beans matching each types found for instance.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-processinjectiontarget-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-processinjectiontarget-code-event&quot;&gt;&lt;/a&gt;&lt;code&gt;ProcessInjectionTarget&lt;/code&gt; event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;An &lt;code&gt;InjectionTarget&lt;/code&gt; can be seen as a non managed bean.
      It mainly provides dependency injection mechanism and some callback feature.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is fired for all elements supporting injection.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface ProcessInjectionTarget&amp;lt;X&amp;gt; { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          public AnnotatedType&amp;lt;X&amp;gt; getAnnotatedType(); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          public InjectionTarget&amp;lt;X&amp;gt; getInjectionTarget(); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          public void setInjectionTarget(InjectionTarget&amp;lt;X&amp;gt; injectionTarget); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
          public void addDefinitionError(Throwable t); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;the event is a parameterized type to target a specific base type of the &lt;code&gt;InjectionTarget&lt;/code&gt; to process&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the &lt;code&gt;AnnotatedType&lt;/code&gt; which defined the processed &lt;code&gt;InjectionTarget&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the &lt;code&gt;InjectionTarget&lt;/code&gt; processed by this event&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows replacing the processed &lt;code&gt;InjectionTarget&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows observer to abort deployment by adding a definition error&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Observing this event allows an extension to override the default InjectionTarget behaviour and perform specific tasks during injection like calling specific feature on a 3rd party framework.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-processbeanattributes-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-processbeanattributes-code-event&quot;&gt;&lt;/a&gt;&lt;code&gt;ProcessBeanAttributes&lt;/code&gt; event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is fired before registration of a discovered bean in the container.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Observing this event allows attributes modification or registration canceling.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is fired for all kind of beans:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;Managed Beans&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Session Beans&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Producer Fields&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Producer Method&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Custom Beans&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface ProcessBeanAttributes&amp;lt;T&amp;gt; { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          public Annotated getAnnotated(); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          public BeanAttributes&amp;lt;T&amp;gt; getBeanAttributes(); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          public void setBeanAttributes(BeanAttributes&amp;lt;T&amp;gt; beanAttributes); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
          public void addDefinitionError(Throwable t); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
          public void veto(); &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;(6)&lt;/b&gt;
      
          /* New in CDI 2.0 */
          public BeanAttributesConfigurator&amp;lt;T&amp;gt; configureBeanAttributes(); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
          public void ignoreFinalMethods(); &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;&lt;b&gt;(7)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;The event being a parameterized type allows observing this event only for a given type&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the Annotated defining the bean (i.e an &lt;code&gt;AnnotatedType&lt;/code&gt; for managed Bean or a session bean, an &lt;code&gt;AnnotatedField&lt;/code&gt; or &lt;code&gt;AnnotatedMethod&lt;/code&gt; for a producer and null for a custom bean)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the processed &lt;code&gt;BeanAttributes&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows replacement of processed &lt;code&gt;BeanAttributes&lt;/code&gt; either by implementing the &lt;code&gt;BeanAttributes&lt;/code&gt; interface or by using a &lt;code&gt;BeanAttributesConfigurator&lt;/code&gt; (new in CDI 2.0)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows observer to abort deployment by adding a definition error&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;6&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;requests the container to ignore the matching bean and skip its registration&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;&lt;b&gt;7&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;new method in CDI 2.0 to explicitly skip some restriction in the spec regarding proxy creation&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The following extension checks that no beans was added by developer for type &lt;code&gt;SpecialClass&lt;/code&gt; and no qualifiers will be registered since it will register a custom bean for it&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class CheckExtension implements Extension {
      
      public void filterSpecialClassBean(@Observes ProcessBeanAttributes&amp;lt;SpecialClass&amp;gt; pba) {
              if(pba.getBeanAttributes().getQualifiers().contains(Default.Literal.INSTANCE))
                  pba.veto();
          }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-processbean-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-processbean-code-event&quot;&gt;&lt;/a&gt;&lt;code&gt;ProcessBean&lt;/code&gt; event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is fired when a bean is registered in the container.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface ProcessBean&amp;lt;X&amp;gt; { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          public Annotated getAnnotated(); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          public Bean&amp;lt;X&amp;gt; getBean(); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          public void addDefinitionError(Throwable t); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Parameterized type for better observer filtering&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the Annotated defining the bean (i.e an &lt;code&gt;AnnotatedType&lt;/code&gt; for managed Bean or a session bean, an &lt;code&gt;AnnotatedField&lt;/code&gt; or &lt;code&gt;AnnotatedMethod&lt;/code&gt; for a producer and null for a custom bean)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the created &lt;code&gt;Bean&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows observer to abort deployment by adding a definition error&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is mainly here to check that a specific bean is created and sometimes capture its definition for further use.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;An observer on &lt;code&gt;ProcessBean&lt;/code&gt; for all kind of bean.
      If you want to be more specific, you can use a child of this event to only observe the event for a specific kind of bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/processBean_hierarchy.svg&quot; alt=&quot;processBean hierarchy&quot; width=&quot;100%&quot; height=&quot;371&quot; /&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-processproducer-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-processproducer-code-event&quot;&gt;&lt;/a&gt;&lt;code&gt;ProcessProducer&lt;/code&gt; event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is fired for all producers find in the application.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Remember that a producer is a kind of bean.
      But its definition and discovery depends on the bean that contains it.
      In other words, producer defined in a class that will not be discovered as bean will be ignored.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It mainly allows overriding of the producing code (i.e. you can override the code written to produce a specific bean instance in the application from an extension )&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface ProcessProducer&amp;lt;T, X&amp;gt; { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          AnnotatedMember&amp;lt;T&amp;gt; getAnnotatedMember(); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          Producer&amp;lt;X&amp;gt; getProducer(); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          void addDefinitionError(Throwable t); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
          void setProducer(Producer&amp;lt;X&amp;gt; producer); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
      
          /* New in CDI 2.0 */
          ProducerConfigurator&amp;lt;X&amp;gt; configureProducer(); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Parameterized type for better observer filtering.
      &lt;code&gt;T&lt;/code&gt; is the bean class of the bean containing the producer, &lt;code&gt;X&lt;/code&gt; is the type of the producer&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the AnnotatedMember defining the producer (i.e an &lt;code&gt;AnnotatedField&lt;/code&gt; for a field producer or &lt;code&gt;AnnotatedMethod&lt;/code&gt; for a method producer)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the producer being processed&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows observer to abort deployment by adding a definition error&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Allow replacement of the processed producer, either by implementing the &lt;code&gt;Producer&lt;/code&gt; interface or using the &lt;code&gt;ProducerConfigurator&lt;/code&gt; helper (new in CDI 2.0)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The following example is inspired by &lt;a href=&quot;https://github.com/astefanutti/metrics-cdi&quot;&gt;Metrics-CDI extension&lt;/a&gt;.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;When user will declare a producer for a metric in the app, we want to check in the metric registry that it doesn’t already exist.
      If it exist, instead of creating an new instance, we’ll return the one in the registry.
      If it doesn’t exist, we’ll use the producer code to instantiate the metric, add it to the registry and returns it to the application.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MetricsExtension implements Extension {
      
      &amp;lt;T extends com.codahale.metrics.Metric&amp;gt; void processMetricProducer(@Observes ProcessProducer&amp;lt;?, T&amp;gt; pp, BeanManager bm) { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
              Metric m = pp.getAnnotatedMember().getAnnotation(Metric.class); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      
              if (m != null) { &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
                  String name = m.name(); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
                  Producer&amp;lt;T&amp;gt; prod = pp.getProducer(); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
                  pp.configureProducer() &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;(6)&lt;/b&gt;
                          .produceWith(ctx -&amp;gt; { &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;&lt;b&gt;(7)&lt;/b&gt;
                              MetricRegistry reg = bm.createInstance().select(MetricRegistry.class).get(); &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;&lt;b&gt;(8)&lt;/b&gt;
                              if (!reg.getMetrics().containsKey(name)) &lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;&lt;b&gt;(9)&lt;/b&gt;
                                  reg.register(name, prod.produce(ctx)); &lt;i class=&quot;conum&quot; data-value=&quot;10&quot;&gt;&lt;/i&gt;&lt;b&gt;(10)&lt;/b&gt;
                              return (T) reg.getMetrics().get(name);  &lt;i class=&quot;conum&quot; data-value=&quot;11&quot;&gt;&lt;/i&gt;&lt;b&gt;(11)&lt;/b&gt;
                          });
              }
          }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;this observer needs &lt;code&gt;BeanManager&lt;/code&gt;. This helper bean can be injected in any observer in an extension&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;retrieving &lt;code&gt;@Metric&lt;/code&gt; annotation on the producer&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;treatment will be skip if no annotation found&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;retrieving name of the metric from the annotation&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;getting the initial producer to be able to use it in call back&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;6&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;we use the new &lt;code&gt;ProducerConfigurator&lt;/code&gt; helpers. In CDI 1.2 we would have created our own implementation of &lt;code&gt;Producer&lt;/code&gt; interface&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;&lt;b&gt;7&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;we define a functional callback for producing the instance of the producer&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;&lt;b&gt;8&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;retrieving the registry bean instance&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;&lt;b&gt;9&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;looking for a metric with the matching name&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;10&quot;&gt;&lt;/i&gt;&lt;b&gt;10&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;if it doesn’t exist we create it by using the original producer code and it to the registry&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;11&quot;&gt;&lt;/i&gt;&lt;b&gt;11&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;we return the metric with the matching name from the registry&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-processobservermethod-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-processobservermethod-code-event&quot;&gt;&lt;/a&gt;&lt;code&gt;ProcessObserverMethod&lt;/code&gt; event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is fired for all observers declared in enabled beans.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Before CDI 2.0 it was mainly an event to check existence of an observer method.
      Since CDI 2.0, this gives more control by allowing &lt;code&gt;ObserverMethod&lt;/code&gt; replacement or removing of it.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface ProcessObserverMethod&amp;lt;T, X&amp;gt; { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          AnnotatedMethod&amp;lt;X&amp;gt; getAnnotatedMethod(); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          ObserverMethod&amp;lt;T&amp;gt; getObserverMethod(); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          void addDefinitionError(Throwable t); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
      
          /* new in CDI 2.0 */
          void setObserverMethod(ObserverMethod&amp;lt;T&amp;gt; observerMethod); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
          ObserverMethodConfigurator&amp;lt;T&amp;gt; configureObserverMethod(); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
          void veto(); &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;(6)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Parameterized type for better observer filtering.
      &lt;code&gt;T&lt;/code&gt; is the bean class of the bean containing the observer method, &lt;code&gt;X&lt;/code&gt; is the type of the event&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the &lt;code&gt;AnnotatedMethod&lt;/code&gt; defining the &lt;code&gt;ObserverMethod&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns the &lt;code&gt;ObserverMethod&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows observer to abort deployment by adding a definition error&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allow replacement or overriding of the &lt;code&gt;ObserverMethod&lt;/code&gt; either by providing a custom &lt;code&gt;ObserverMethod&lt;/code&gt; instance or by using an &lt;code&gt;ObserverMethodConfigurator&lt;/code&gt; (new in CDI 2.0)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The example below show how an extension can switch all synchronous observer for MyClass event type to asynchronous behaviour.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class SwitchExtension implements Extension {
      
         public void switchToAsync(@Observes ProcessObserverMethod&amp;lt;?, MyClass&amp;gt; pom) {
             pom.configureObserverMethod().async(true);
         }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-afterbeandiscovery-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-afterbeandiscovery-code-event&quot;&gt;&lt;/a&gt;&lt;code&gt;AfterBeanDiscovery&lt;/code&gt; event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is fired after all beans, producers and observer discovery.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It is the last occasion to change or enhance discovered meta data.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface AfterBeanDiscovery {
          void addDefinitionError(Throwable t); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          void addBean(Bean&amp;lt;?&amp;gt; bean); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          void addObserverMethod(ObserverMethod&amp;lt;?&amp;gt; observerMethod); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          void addContext(Context context); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
          &amp;lt;T&amp;gt; AnnotatedType&amp;lt;T&amp;gt; getAnnotatedType(Class&amp;lt;T&amp;gt; type, String id); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
          &amp;lt;T&amp;gt; Iterable&amp;lt;AnnotatedType&amp;lt;T&amp;gt;&amp;gt; getAnnotatedTypes(Class&amp;lt;T&amp;gt; type); &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;(6)&lt;/b&gt;
      
          /* New in CDI 2.0 */
          &amp;lt;T&amp;gt; BeanConfigurator&amp;lt;T&amp;gt; addBean(); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          &amp;lt;T&amp;gt; ObserverMethodConfigurator&amp;lt;T&amp;gt; addObserverMethod(); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows observer to abort deployment by adding a definition error&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows creation of a custom bean either by creating a custom implementation of &lt;code&gt;Bean&lt;/code&gt; interface or by using the &lt;code&gt;BeanConfigurator&lt;/code&gt; helper (new in CDI 2.0).
      registering a custom bean will trigger all the events linked to bean discovery and creation.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows  creation of an &lt;code&gt;ObserverMethod&lt;/code&gt; either by creating a custom implementation of &lt;code&gt;ObserverMethod&lt;/code&gt; interface or by using the &lt;code&gt;ObserverMethodConfigurator&lt;/code&gt; helper (new in CDI 2.0).&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;add a nex context to the container&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns a discovered &lt;code&gt;AnnotatedType&lt;/code&gt; for the given class and id.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;6&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;returns an &lt;code&gt;Iterable&lt;/code&gt; on all the discovered &lt;code&gt;AnnotatedType&lt;/code&gt; in the application&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-afterdeploymentvalidation-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-afterdeploymentvalidation-code-event&quot;&gt;&lt;/a&gt;&lt;code&gt;AfterDeploymentValidation&lt;/code&gt; event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This last bootstrapping event is only a hook to check that everything is as expected in the meta data (remember that the observer can inject BeanManager to inspect these meta data).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;When this event is fired, the meta data in the container are no more mutable and the application is ready to run&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface AfterDeploymentValidation {
          void addDeploymentProblem(Throwable t); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;allows observer to abort deployment by adding a definition error&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;application-life-and-death&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#application-life-and-death&quot;&gt;&lt;/a&gt;Application life and death&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;From the portable extension perspective we are nearly done.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;After this rich phase of bootstrapping, the application runs until an event request its shutting down.
      It’s when the last portable extension event is fired.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-beforeshutdown-code-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-beforeshutdown-code-event&quot;&gt;&lt;/a&gt;&lt;code&gt;BeforeShutdown&lt;/code&gt; Event&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This event is a hook, to allow cleaning of specific resource created during application life&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public interface BeforeShutdown {
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Portable extension are a very powerful tool.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Mastering them may seems difficult, but once you understand most of the SPI and the container lifecycle shown in this post, it’s no more than a kind of big lego box only limited by your imagination.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    </content>
  </entry>
  <entry>
    <id>http://www.next-presso.com/2016/02/cdi-the-spi-who-loved-me.html</id>
    <title>CDI, the SPI who loved me</title>
    <updated>2017-02-07T16:51:38+01:00</updated>
    <published>2016-02-20T00:00:00+00:00</published>
    <link href="http://www.next-presso.com/2016/02/cdi-the-spi-who-loved-me.html" rel="alternate" type="text/html" />
    <category term="CDI"></category>
    <category term="SPI"></category>
    <category term="Extension"></category>
    <summary>
      CDI users ask me very often why they should adopt CDI and stop using their old framework or way of doing their developments.
      The answer to this question can be found in advanced CDI stuff: extension mechanism and CDI SPI.
      
      
      Yes, CDI true killing feature is not accessible out of the box and you have to dig into the spec to grab its power.
      Unfortunately, the way it&#8217;s introduced and explained in the specification document doesn&#8217;t make it particularly shine.
      
      
      With this article and a coming one on portable extensions, I&#8217;ll try to fix that and help beginner users to get an overview of...
    </summary>
    <content type="html">
      &lt;div class=&quot;imageblock&quot; style=&quot;float: left&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/posts/2016/legobricks.jpg&quot; alt=&quot;legobricks&quot; width=&quot;285&quot; /&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI users ask me very often why they should adopt CDI and stop using their old framework or way of doing their developments.
      The answer to this question can be found in advanced CDI stuff: extension mechanism and CDI SPI.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Yes, CDI true killing feature is not accessible out of the box and you have to dig into the spec to grab its power.
      Unfortunately, the way it’s introduced and explained in the specification document doesn’t make it particularly shine.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;With this article and a coming one on portable extensions, I’ll try to fix that and help beginner users to get an overview of the power they’ll have if they invest time in learning CDI SPI.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;I’ll try to show you all the aspects of the CDI SPI and how you can use part of it in your day to day work.
      In this article I’ll use the term &quot;usual code&quot; in opposition to portable extension code to differentiate standard development from development to extend CDI.
      At the end of the day you’ll see how much the CDI SPI loves developers ;).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;what-is-this-spi&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#what-is-this-spi&quot;&gt;&lt;/a&gt;What is this SPI?&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI SPI is the introspection part of the spec allowing developers to access meta-information about CDI concepts (Beans, events, injection point, interceptors, etc…​)&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;While some of you may be more familiar with the term API (Application Programming Interface), the CDI specification is mainly built on a SPI concept (Service Provider Interface).
      So what’s the difference?&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;An API is the description of classes/interfaces/methods/…​ that you call and use to achieve a goal&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;An SPI is the description of classes/interfaces/methods/…​ that you extend and implement to achieve a goal&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;To make short, CDI provides interfaces that you implement (or that spec implementation implement for you) to perform a specific task.
      Access to these implementation are usually done through injection or event observation but you’ll have on the rare occasion to create your own implementation.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;To ease the understand of the SPI, I’d like to split in 4 parts:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;CDI entry points&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Type meta-model&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;CDI meta-model&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;SPI dedicated to extensions&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This division is a subjective approach I use to introduce elements of the SPI, it doesn’t reflect organisation of CDI packages or documentation.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Let’s explore these different parts&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;spi-providing-cdi-entry-points&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#spi-providing-cdi-entry-points&quot;&gt;&lt;/a&gt;SPI providing CDI entry points&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Usually, when you develop a Java EE application you don’t have to bother &quot;entering&quot; in CDI bean graph.
      It’s automatically done from the UI (via expression language), CDI event triggered automatically at boot time or EJB call.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;But sometimes, you may need to access CDI from non CDI code or plug non CDI code to CDI beans at run time.
      This part of the SPI gives you the tools to do it.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/entry-points.svg&quot; alt=&quot;entry points&quot; width=&quot;100%&quot; height=&quot;726&quot; /&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-beanmanager-code-and-code-cdi-code&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-beanmanager-code-and-code-cdi-code&quot;&gt;&lt;/a&gt;&lt;code&gt;BeanManager&lt;/code&gt; and &lt;code&gt;CDI&lt;/code&gt;&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In CDI 1.0 the only solution you had to access CDI bean graph was to retrieve the &lt;code&gt;BeanManager&lt;/code&gt; from JNDI&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;BeanManager bm = null;
      try {
          InitialContext context = new InitialContext();
          bm = (BeanManager) context.lookup(&quot;java:comp/BeanManager&quot;);
      } catch (Exception e) {
          e.printStackTrace();
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The &lt;code&gt;BeanManager&lt;/code&gt; is a central interface in CDI SPI, giving access to all meta-data and instantiated components in your application.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Checking its &lt;a href=&quot;http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#beanmanager&quot; target=&quot;_blank&quot;&gt;section in spec&lt;/a&gt; or its &lt;a href=&quot;http://docs.jboss.org/cdi/api/1.2/javax/enterprise/inject/spi/BeanManager.html&quot;&gt;javadoc&lt;/a&gt; gives a complete overview of all the features it contains.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The main reason for developers to access CDI from non CDI code is to request a &lt;code&gt;Bean&lt;/code&gt; instance to enter the CDI bean graph.
      Doing so with the BeanManager is a bit verbose.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;BeanManager bm = null;
      try {
          InitialContext context = new InitialContext();
          bm = (BeanManager) context.lookup(&quot;java:comp/BeanManager&quot;); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      } catch (Exception e) {
          e.printStackTrace();
      }
      Set&amp;lt;Bean&amp;lt;?&amp;gt;&amp;gt; beans = bm.getBeans(MyService.class); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      Bean&amp;lt;?&amp;gt; bean =  bm.resolve(beans); &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
      CreationalContext&amp;lt;MyService&amp;gt; ctx = bm.createCreationalContext(bean); &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
      MyService myService = (MyService) bm.getReference(bean, MyService.class, ctx); &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Retrieving BeanManager thru JNDI&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;retrieving all the beans having MyService in their type and the @Default qualifier&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;apply the ambiguous dependency resolution for the set of beans&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;create a &lt;code&gt;CreationalContext&lt;/code&gt; to help contextual instance creation for complex use cases like circularities&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;get the instance&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This verbosity is the proof that the &lt;code&gt;BeanManager&lt;/code&gt; is and advanced CDI tool allowing very basic operation on CDI echos system.
      It’s obviously not the best solution if you just want to access an instance.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;That’s why, in CDI 1.1  we introduced the abstract &lt;code&gt;CDI&lt;/code&gt; class which use Java Service Loader to retrieve a concrete &lt;code&gt;CDI&lt;/code&gt; class from the implementation.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;CDI&amp;lt;Object&amp;gt; cdi = CDI.current();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;code&gt;CDI&lt;/code&gt; gives a faster access to the BeanManager with &lt;code&gt;CDI.getBeanManager()&lt;/code&gt; method, but more interestingly, it provides a convenient way to request a contextual instance without using the cumbersome code with &lt;code&gt;BeanManager&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;As &lt;code&gt;CDI&lt;/code&gt; extends &lt;code&gt;Instance&amp;lt;Object&amp;gt;&lt;/code&gt; it naturally provides contextual instance resolution with &lt;a href=&quot;http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#programmatic_lookup&quot; target=&quot;_blank&quot;&gt;programmatic lookup&lt;/a&gt;.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;To make short accessing &lt;code&gt;CDI&lt;/code&gt; in your non CDI code provides the same service than having the following injection in CDI code.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Inject @Any Instance&amp;lt;Object&amp;gt; cdi;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Retrieving an instance becomes as simple as&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;CDI&amp;lt;Object&amp;gt; cdi = CDI.current();
      MyService service = cdi.select(MyService.class).get();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-unmanaged-code&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-unmanaged-code&quot;&gt;&lt;/a&gt;&lt;code&gt;Unmanaged&lt;/code&gt;&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI 1.1 introduced an other nice feature to help you integrating CDI in non CDI code.
      The &lt;code&gt;Unmanaged&lt;/code&gt; class allows you to apply some CDI operation to a non CDI class.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;With it you can call lifecycle callbacks (&lt;code&gt;@Postconstruct&lt;/code&gt; and &lt;code&gt;@Predestroy&lt;/code&gt;) and perform injection on such class instance.
      Third party framework developers can then provide their non CDI class including injection point (remember &lt;code&gt;@Inject&lt;/code&gt; is not part of CDI spec but AtInject spec) and Unmanaged can be used to get instances of this class.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For instance, imagine this class included in a non CDI archive.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class NonCDI {
      
        @Inject
        SomeClass someInstance;
      
        @PostConstruct
        public void init()  {
        ...
        }
      
        @Predestroy
        public void cleanUp() {
        ...
        }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;You can obtain an instance of this class with injection point satisfied with this code&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Unmanaged&amp;lt;NonCDI&amp;gt; unmanaged = new Unmanaged(NonCDI.class);
      UnmanagedInstance&amp;lt;NonCDI&amp;gt; inst = unmanaged.newInstance();
      NonCDI nonCdi = inst.produce().inject().postConstruct().get();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;By checking the &lt;a href=&quot;https://github.com/cdi-spec/cdi/blob/1.2/api/src/main/java/javax/enterprise/inject/spi/Unmanaged.java&quot;&gt;code in Unmanaged and UnManagedInstance&lt;/a&gt; classes you can see how other CDI SPI interfaces are used to provide this feature^&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;spi-for-type-meta-model&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#spi-for-type-meta-model&quot;&gt;&lt;/a&gt;SPI for type meta-model&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;As all configuration in CDI is based on annotations, we need a mutable meta-model to create or modify existing configuration.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In an other world we could have rely on JDK for type representation and reflection, but as it is read only we had to create our own model in CDI.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/type-meta.svg&quot; alt=&quot;type meta&quot; width=&quot;100%&quot; height=&quot;518&quot; /&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The &lt;code&gt;AnnotatedType&lt;/code&gt; interface is main element of this annotation centric type meta-model.
      other interfaces are abstraction or contained by it.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Defining an &lt;code&gt;AnnotatedType&lt;/code&gt; let’s you put all annotations you need on the type, fields, methods or method parameters.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;code&gt;AnnotatedType&lt;/code&gt; are mainly used in portable extension
      They are constructed by the container from existing types.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;As you can see, this model has no CDI specific feature, so if a third party developer decide to couple his framework to CDI he can allow his users to play with &lt;code&gt;AnnotatedType&lt;/code&gt; to configure his framework&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;spi-dedicated-to-cdi-meta-model&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#spi-dedicated-to-cdi-meta-model&quot;&gt;&lt;/a&gt;SPI dedicated to CDI meta-model&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;I already gave a good overview of the interfaces related to Bean meta model in my &lt;a href=&quot;http://www.next-presso.com/2015/12/how-to-recognize-different-types-of-cdi-beans/&quot; target=&quot;_blank&quot;&gt;previous article&lt;/a&gt;, so I wont go back into detail on it.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/bean-meta.svg&quot; alt=&quot;bean meta&quot; width=&quot;645&quot; height=&quot;436&quot; /&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Just remember that while this meta-model is mainly used in portable extensions to declare custom beans, it can also be used in your bean to get introspection feature about the current bean, interceptor, decorator or the currently intercepted or decorated bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The rest of the CDI meta data SPI interfaces are below:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/cdi-meta.svg&quot; alt=&quot;cdi meta&quot; width=&quot;100%&quot; height=&quot;522&quot; /&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-observermethod-code-and-code-eventmetadata-code&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-observermethod-code-and-code-eventmetadata-code&quot;&gt;&lt;/a&gt;&lt;code&gt;ObserverMethod&lt;/code&gt; and &lt;code&gt;EventMetaData&lt;/code&gt;&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;code&gt;ObserverMethod&lt;/code&gt; interface represent meta data for a given observer method and doesn’t have any usage outside a potable extension.
      So I’ll deal with in my next article on extensions.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;code&gt;EventMetadata&lt;/code&gt; is also related to events but at the opposite logic of &lt;code&gt;EventMetadata&lt;/code&gt;, it is only used in usual code and never in an extension.
      You can inject it in your observer to get information about the event that triggered it.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For instance, you can use it to have stricter approach to observer resolution.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;As I wrote in my &lt;a href=&quot;http://www.next-presso.com/2014/06/you-think-you-know-everything-about-cdi-events-think-again/&quot; target=&quot;_blank&quot;&gt;event post&lt;/a&gt;, observer resolution for a given type and qualifiers set, also include an observer for any subclass of the event type and without any qualifier.
       You could use &lt;code&gt;EventMetadata&lt;/code&gt; to restrict this rule by checking effective event type and qualifier like this:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MyService {
        private void strictListen(@Observes @Qualified Payload evt, EventMetadata meta) {
          if(meta.getQualifiers().contains(new QualifiedLiteral())
             &amp;amp;&amp;amp; meta.getType().equals(Payload.class))
               System.out.println(&quot;Do something&quot;) &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
             else
               System.out.println(&quot;ignore&quot;)
        }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;this code will be executed only if event type is strictly &lt;code&gt;Payload&lt;/code&gt; and its qualifiers contains &lt;code&gt;@Qualified&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-producer-code-and-code-injectiontarget-code-and-their-factories&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-producer-code-and-code-injectiontarget-code-and-their-factories&quot;&gt;&lt;/a&gt;&lt;code&gt;Producer&lt;/code&gt; and &lt;code&gt;InjectionTarget&lt;/code&gt; and their factories&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;code&gt;Producer&lt;/code&gt; and &lt;code&gt;InjectionTarget&lt;/code&gt; are also mostly used in extension.
      But if you took a look to &lt;code&gt;Unmanaged&lt;/code&gt; presented above you may have seen that &lt;code&gt;InjectionTarget&lt;/code&gt; can be used in usual code to perform some lifecycle operations an injection on a non CDI class.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;As &lt;code&gt;Unmanaged&lt;/code&gt; doesn’t allow you to perform injection on existing object you can use this code to do it yourself.
      This can be useful if you want to have object provided by a third party, perform injection in CDI way.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;AnnotatedType&amp;lt;MyClass&amp;gt; type = beanManager.createAnnotatedType(MyClass.class);
      InjectionTarget&amp;lt;MyClass&amp;gt; injectionTarget = beanManager.getInjectionTargetFactory(MyClass.class).createInjectionTarget(null);
      CreationalContext&amp;lt;MyClass&amp;gt; ctx = beanManager.createCreationalContext(null);
      
      MyClass instance = new Myclass;
      injectionTarget.inject(instance, ctx);
      injectionTarget.postConstruct(instance);&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI 1.1 introduced &lt;code&gt;ProducerFactory&lt;/code&gt; and &lt;code&gt;InjectionTargetFactory&lt;/code&gt; to resolve circular dependency issues when using &lt;code&gt;Producer&lt;/code&gt; or &lt;code&gt;InjectionTarget&lt;/code&gt; in an extension to create a new kind of &lt;code&gt;Bean&lt;/code&gt;.
      I will detail them in my next post.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;code-injectionpoint-code-meta-data&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#code-injectionpoint-code-meta-data&quot;&gt;&lt;/a&gt;&lt;code&gt;InjectionPoint&lt;/code&gt; meta-data&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Last but not least in this SPI family: the &lt;code&gt;InjectionPoint&lt;/code&gt;.
      This swiss-army knife is as much used in extension than in usual code.
      But in the later case you can only use it to get information on injection point related to &lt;code&gt;@Dependent&lt;/code&gt; scoped bean.
      It’s the only way to guarantee the injection point uniqueness (i.e. the same &lt;code&gt;@RequestScoped&lt;/code&gt; instance can be injected in multiple place).
      That’s the price to access &lt;code&gt;InjectionPoint&lt;/code&gt; power.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Let’s check some nice way to use the &lt;code&gt;InjectionPoint&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;using-a-qualifier-to-pass-parameter-to-a-producer&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#using-a-qualifier-to-pass-parameter-to-a-producer&quot;&gt;&lt;/a&gt;Using a qualifier to pass parameter to a producer&lt;/h4&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;As &lt;code&gt;InjectionPoint&lt;/code&gt; is used to get info about what’s being injected, info included in a qualifier can be used to decide what to return in a producer&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;First let’s create a qualifier with non binding member&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Qualifier
      @Retention(RetentionPolicy.RUNTIME)
      public @interface HttpParam {
          @Nonbinding public String value(); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;This qualifier integrates a non binding member, that let us pass information to our producer&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Then a producer for a dependent bean that analysis info at his injection point.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Produces
      @HttpParam(&quot;&quot;) &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      @Dependent &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      String getParamValue(InjectionPoint ip, HttpServletRequest req) { &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
        return req.getParameter(ip.getAnnotated().getAnnotation(HttpParam.class).value());
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;This producer defines a bean having &lt;code&gt;String&lt;/code&gt; in its type set and qualified with our qualifier&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;Remember to use injection point in your bean must be in dependent scope.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;this producer injects the &lt;code&gt;InjectionPoint&lt;/code&gt; meta-data and the built-in &lt;code&gt;HttpServletRequest&lt;/code&gt; bean&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Finally we can use this producer by injecting the matching bean type and qualifier, with the parameter in the qualifier&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Inject
      @HttpParam(&quot;productId&quot;)
      String productId;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;analyze-requested-types-a-injection-point&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#analyze-requested-types-a-injection-point&quot;&gt;&lt;/a&gt;Analyze requested types a injection point&lt;/h4&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI does a great job to avoid type erasure and guarantee a powerful usage of parameterized types.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In the example below, we have a producer for a generic &lt;code&gt;Map&lt;/code&gt; that use different implementations depending on the type of map values requested at the injection point.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;class MyMapProducer() {
      
          @Produces
          &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; produceMap(InjectionPoint ip) {
              if (valueIsNumber(((ParameterizedType) ip.getType()))) &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
                  return new TreeMap&amp;lt;K, V&amp;gt;();
              return new HashMap&amp;lt;K, V&amp;gt;();
          }
      
          boolean valueIsNumber(ParameterizedType type) { &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
              Class&amp;lt;?&amp;gt; valueClass = (Class&amp;lt;?&amp;gt;) type.getActualTypeArguments()[1];
              return Number.class.isAssignableFrom(valueClass)
          }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;this code retrieve the parameterized type defined at the injection point and send it to the test function&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;this test function will check the effective type of the second type prameter (type of the map values) and return true if this type inherit &lt;code&gt;Number&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;With the code above &lt;code&gt;@Inject Map&amp;lt;String,String&amp;gt; map&lt;/code&gt; will use an &lt;code&gt;HashMap&lt;/code&gt; under the hood while &lt;code&gt;@Inject Map&amp;lt;String,Integer&amp;gt; map&lt;/code&gt; will use a &lt;code&gt;TreeMap&lt;/code&gt;.
      An elegant way to optimize or change behaviour without leakage in business code.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#conclusion&quot;&gt;&lt;/a&gt;conclusion&lt;/h4&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;There are lot of features you can imagine to build with &lt;code&gt;InjectionPoint&lt;/code&gt; and keep in mind that we only saw a few example in usual code.
      Imagine what you can do in an extension…​&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;spi-dedicated-to-extensions&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#spi-dedicated-to-extensions&quot;&gt;&lt;/a&gt;SPI dedicated to extensions&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Let’s end this SPI tour by a cliffhanger.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The following SPI classes are totally dedicated to extension development.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In fact they defined events type for each step in the container lifecycle (mainly the bootstrap part) where the portable extension magic occurs.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/spi-extensions.svg&quot; alt=&quot;spi extensions&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Let’s discover this magic in a coming post about extension.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    </content>
  </entry>
  <entry>
    <id>http://www.next-presso.com/2015/12/how-to-recognize-different-types-of-cdi-beans.html</id>
    <title>How to recognize different types of beans from quite a long way away</title>
    <updated>2017-02-07T16:51:38+01:00</updated>
    <published>2015-12-14T00:00:00+00:00</published>
    <link href="http://www.next-presso.com/2015/12/how-to-recognize-different-types-of-cdi-beans.html" rel="alternate" type="text/html" />
    <category term="CDI"></category>
    <category term="Beans"></category>
    <category term="EJB"></category>
    <summary>
      In CDI, Beans are a very centric concept.
      Yet, for a lot of user, this concept stays fuzzy and requires experiment to achieve an expected result.
      In this article I&#8217;ll try to clarify most of bean related concepts and detail the hidden mechanism behind bean definition and injection.
      
      
      
      
      Bean, contextual instance and typesafe resolution
      
      
      When most CDI users write
      
      
      
      @Inject
      @MyQualifier
      MyBean bean;
      
      
      
      they think: "I have injected the MyBean bean having @MyQualifier qualifier".
      
      
      That&#8217;s not correct and it&#8217;s important to understand the exact mechanism behind this injection point definition.
      
      
      Bean vs contextual instances
      
      One of the specific feature in CDI is the fact that all components (qualifiers, beans, producers, etc..)...
    </summary>
    <content type="html">
      &lt;div id=&quot;preamble&quot;&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;imageblock&quot; style=&quot;float: right&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/posts/2015/the_larch.jpg&quot; alt=&quot;the larch&quot; width=&quot;200&quot; /&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In CDI, Beans are a very centric concept.
      Yet, for a lot of user, this concept stays fuzzy and requires experiment to achieve an expected result.
      In this article I’ll try to clarify most of bean related concepts and detail the hidden mechanism behind bean definition and injection.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;bean-contextual-instance-and-typesafe-resolution&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#bean-contextual-instance-and-typesafe-resolution&quot;&gt;&lt;/a&gt;Bean, contextual instance and typesafe resolution&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;When most CDI users write&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Inject
      @MyQualifier
      MyBean bean;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;they think: &quot;I have injected the &lt;code&gt;MyBean&lt;/code&gt; bean having &lt;code&gt;@MyQualifier&lt;/code&gt; qualifier&quot;.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;That’s not correct and it’s important to understand the exact mechanism behind this injection point definition.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;bean-vs-contextual-instances&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#bean-vs-contextual-instances&quot;&gt;&lt;/a&gt;Bean vs contextual instances&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;One of the specific feature in CDI is the fact that all components (qualifiers, beans, producers, etc..) are discovered at deployment time.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It allows the container to raise errors very early (before runtime) and for you to be sure that all injection points you defined will be satisfied and not ambiguous.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;While this discovery process is not the topic of this article you should know that all classes packaged with your application will be analyzed at deployment to discover beans (and other components).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;At the end of this discovery task, the container had created collections of meta-data for most elements included in CDI SPI.
      The more centric meta-data created by CDI container is the collection of &lt;code&gt;Bean&amp;lt;T&amp;gt;&lt;/code&gt; discovered during deployment.
      These metadata are the real applications &lt;em&gt;beans&lt;/em&gt; and in basic CDI usage you’ll never use them.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;So don’t mix &lt;em&gt;beans&lt;/em&gt; and the &lt;em&gt;contextual instances&lt;/em&gt; (instances of the bean for a given context) you request to the container when adding an injection point in your code.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;the-content-of-code-bean-t-code-interface&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#the-content-of-code-bean-t-code-interface&quot;&gt;&lt;/a&gt;The content of &lt;code&gt;Bean&amp;lt;T&amp;gt;&lt;/code&gt; interface&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The &lt;code&gt;Bean&lt;/code&gt; interface has two main functions:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;Providing a &quot;recipe&quot; to create and destroy contextual instances (methods from &lt;code&gt;Contextual&amp;lt;T&amp;gt;&lt;/code&gt;)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Storing bean metadata obtained from bean definition (methods from &lt;code&gt;BeanAttributes&amp;lt;T&amp;gt;&lt;/code&gt;)&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/bean-hierarchy.svg&quot; alt=&quot;Bean Interface hierarchy, yes Interceptor and Decorator are also Beans&quot; width=&quot;645&quot; height=&quot;436&quot; /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;title&quot;&gt;Bean Interface hierarchy, yes Interceptor and Decorator are also Beans&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The metadata stored in &lt;code&gt;Bean&amp;lt;T&amp;gt;&lt;/code&gt; come from the user code defining the bean (type and annotations).
      If you take a look at &lt;code&gt;BeanAttributes&lt;/code&gt; in the above schema, you’ll see that these metadata include a set of types (yes a bean as multiple types) and a set of qualifiers (each bean has at least 2 qualifiers: &lt;code&gt;@Default&lt;/code&gt; and &lt;code&gt;@Any&lt;/code&gt;).
      These 2 sets are used in the CDI typesafe resolution mechanism.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;typesafe-resolution-for-dummies&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#typesafe-resolution-for-dummies&quot;&gt;&lt;/a&gt;Typesafe resolution for Dummies&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;When you use &lt;code&gt;@Inject&lt;/code&gt; in your code, you’re asking the container to look for a certain &lt;code&gt;Bean&lt;/code&gt;.
      The search is done by using info in &lt;code&gt;Bean&lt;/code&gt; metadata.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For most injection point this search is done at deployment time to check if each injection point is satisfied and not ambiguous, the only exception is the programmatic lookup (use of &lt;code&gt;Instance&amp;lt;T&amp;gt;&lt;/code&gt;).
      This approach allows the implementation to cache the matching bean for a given injection point.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;When the matching &lt;code&gt;Bean&lt;/code&gt; is found, the container use its &lt;code&gt;create&lt;/code&gt; method to provide you an instance.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This process, called the &lt;a href=&quot;http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#typesafe_resolution&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;Typesafe resolution&lt;/em&gt;&lt;/a&gt; can be simplified like this:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;When resolving bean for a given injection point the container considers the set of types and qualifiers of all enabled beans to find the right candidate.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;imageblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/typesafe-resolution.svg&quot; alt=&quot;A simplified version of typesafe resolution&quot; width=&quot;841&quot; height=&quot;513&quot; /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;title&quot;&gt;A simplified version of typesafe resolution&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The actual process is a bit more complex with integration of Alternatives, but the general idea is here.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;If the container succeeds in resolving the injection point by finding one and only one eligible bean, the &lt;code&gt;create()&lt;/code&gt; method of this bean will be used to provide an instance for it.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;so-when-do-we-refer-to-the-code-bean-t-code&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#so-when-do-we-refer-to-the-code-bean-t-code&quot;&gt;&lt;/a&gt;So when do we refer to the &lt;code&gt;Bean&amp;lt;T&amp;gt;&lt;/code&gt;?&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In basic CDI, the answer is &quot;never&quot; (or almost).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;code&gt;Bean&amp;lt;T&amp;gt;&lt;/code&gt; will be used 90% of the time in portable extension to create a custom bean or analyse bean metadata.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Since CDI 1.1 you can also use &lt;code&gt;Bean&amp;lt;T&amp;gt;&lt;/code&gt; outside extensions.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For the sake of reflection it is now allowed to inject the bean meta-data in a bean class, an interceptor or a decorator, allowing them to have info on metadata of the current bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For instance this interceptor use the meta-data of the intercepted bean to avoid issue with proxy creation in the implementation:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Loggable
      @Interceptor
      public class LoggingInterceptor {
      
          @Inject
          private Logger logger;
      
          @Inject @Intercepted &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
          private Bean&amp;lt;?&amp;gt; intercepted;
      
          @AroundInvoke
          private Object intercept(InvocationContext ic) throws Exception {
              logger.info(&quot;&amp;gt;&amp;gt; &quot; + intercepted.getBeanClass().getName() + &quot; - &quot; + ic.getMethod().getName()); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
              try {
                  return ic.proceed();
              } finally {
                  logger.info(&quot;&amp;lt;&amp;lt; &quot; + intercepted.getBeanClass().getName() + &quot; - &quot; + ic.getMethod().getName());
              }
          }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;@Intercepted&lt;/code&gt; is a reserved qualifier to inject the intercepted bean in an interceptor&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;here it is used to retrieve the actual class of the contextual instance not the proxy’s class implementation may have created&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;different-kinds-of-cdi-beans&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#different-kinds-of-cdi-beans&quot;&gt;&lt;/a&gt;Different kinds of CDI beans&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Now that we stated the difference between Bean and Bean in stances, it’s time to list all the bean kind we’ve got in CDI and their specific behaviour.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;managed-beans&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#managed-beans&quot;&gt;&lt;/a&gt;Managed beans&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Managed bean are the most obvious kind of bean available in CDI.
      They are defined by a class declaration.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;According to the specification (section &lt;a href=&quot;http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#what_classes_are_beans&quot; target=&quot;_blank&quot;&gt;3.1.1 Which Java classes are managed beans?&lt;/a&gt;):&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;quoteblock&quot;&gt;
      &lt;blockquote&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A top-level Java class is a managed bean if it meets all of the following conditions:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;It is not a non-static inner class.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;It is a concrete class, or is annotated &lt;code&gt;@Decorator&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;It does not implement &lt;code&gt;javax.enterprise.inject.spi.Extension&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;It is not annotated &lt;code&gt;@Vetoed&lt;/code&gt; or in a package annotated &lt;code&gt;@Vetoed&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;It has an appropriate constructor - either:&lt;/p&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;the class has a constructor with no parameters, or&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;the class declares a constructor annotated &lt;code&gt;@Inject&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;All Java classes that meet these conditions are managed beans and thus no special declaration is required to define a managed bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/blockquote&gt;
      &lt;div class=&quot;attribution&quot;&gt;
      — CDI 1.2 specification
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;That’s for the general rules, a valid class can also be ignored if the bean discovery mode is set to &lt;em&gt;none&lt;/em&gt; or &lt;em&gt;annotated&lt;/em&gt; and the class doesn’t have a &lt;a href=&quot;http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#bean_defining_annotations&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;bean defining annotation&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;To sum up, if you’re in the default bean discovery mode (&lt;code&gt;Annotated&lt;/code&gt;) your class should follow the condition above and have at least one of the following annotation to become a CDI managed bean:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;@ApplicationScoped&lt;/code&gt;, &lt;code&gt;@SessionScoped&lt;/code&gt;, &lt;code&gt;@ConversationScoped&lt;/code&gt; and &lt;code&gt;@RequestScoped&lt;/code&gt; annotations,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;all other normal scope types,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;@Interceptor&lt;/code&gt; and &lt;code&gt;@Decorator&lt;/code&gt; annotations,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;all stereotype annotations (i.e. annotations annotated with &lt;code&gt;@Stereotype&lt;/code&gt;),&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;and the &lt;code&gt;@Dependent&lt;/code&gt; scope annotation.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Another limitation is linked to &lt;a href=&quot;http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#client_proxies&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;client proxies&lt;/em&gt;&lt;/a&gt;.
      In a lot of occasion (interceptor or decorator, passivation, usage of normal scope, possible circularity), the container may need to provide a contextual instance wrapped in a proxy.
      For this reason, managed bean classes should be proxyable or the container will raise an exception.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Thus in addition to the above rules the spec also restrictions on managed bean class to support certain services or be in normal scopes.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;So, if possible you should avoid the following limitation on your bean class to be sure that they can be proxyable:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;it should have a non private constructor with parameters,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;it shouldn’t be final,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;it shouldn’t have non static final methods.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;bean-types-of-a-managed-bean&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#bean-types-of-a-managed-bean&quot;&gt;&lt;/a&gt;Bean types of a managed bean&lt;/h4&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The set of bean types (used during typesafe resolution) for a given managed bean contains:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;the bean class,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;evey superclass (including &lt;code&gt;Object&lt;/code&gt;),&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;all interface the class implements directly or indirectly.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Keep in mind that &lt;code&gt;@Typed&lt;/code&gt; annotation can restrict this set.
      When it’s used, only the types whose classes are explicitly listed using the value member, together with &lt;code&gt;Object&lt;/code&gt;, are bean types of the bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;session-beans&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#session-beans&quot;&gt;&lt;/a&gt;Session beans&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI Session beans are EJB in CDI flavor.
      If you define a session bean with EJB 3.x client view in a bean archive without &lt;code&gt;@Vetoed&lt;/code&gt; annotation on it (or on its package) you’ll have a Session Bean at runtime.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Local stateless, singleton or stateful EJB are automatically treated as CDI session bean: they support injection, CDI scope, interception, decoration and all other CDI services.
      Remote EJB and MDB cannot be used as CDI beans.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Note the following restriction regarding EJB and CDI scopes:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;Stateless session beans must belong to the &lt;code&gt;@Dependent&lt;/code&gt; scope,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Singleton session beans can belong to the &lt;code&gt;@Dependent&lt;/code&gt; or &lt;code&gt;@ApplicationScoped&lt;/code&gt; scopes,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Stateful session beans can belong to any scope&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;When using EJB in CDI you have the features of both specifications.
      You can for instance have asynchronous behavior and observer features in one bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;But keep in mind that CDI implementation doesn’t &lt;em&gt;hack&lt;/em&gt; EJB container, it only use it as any EJB client would do.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Thus, if you don’t use &lt;code&gt;@Inject&lt;/code&gt; but &lt;code&gt;@EJB&lt;/code&gt; to inject a session bean, you’ll obtain a plain EJB in your injection point and not a CDI session bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;bean-types-of-a-session-bean&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#bean-types-of-a-session-bean&quot;&gt;&lt;/a&gt;Bean types of a session bean&lt;/h4&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The set of bean types (used during typesafe resolution) for a given CDI session bean depend on its definition:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;If the session has local interfaces, it contains:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;all local interfaces of the bean,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;all super interfaces of these local interfaces, and&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;Object&lt;/code&gt; class.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;If the session bean has a no-interface view, it contains:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;the bean class, and&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;evey superclass (including &lt;code&gt;Object&lt;/code&gt;).&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The set can also be restricted with &lt;code&gt;@Typed&lt;/code&gt;.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;examples&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#examples&quot;&gt;&lt;/a&gt;Examples&lt;/h4&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@ConversationScoped
      @Stateful
      public class ShoppingCart { ... } &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      
      @Stateless
      @Named(&quot;loginAction&quot;)
      public class LoginActionImpl implements LoginAction { ... } &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      
      
      @ApplicationScoped
      @Singleton &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
      @Startup &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
      public class bootBean {
       @Inject
       MyBean bean;
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;A stateful bean (with no-interface view) defined in &lt;code&gt;@ConversationScoped&lt;/code&gt; scope. It has &lt;code&gt;ShoppingCart&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt; in its bean types.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;A stateless bean in &lt;code&gt;@Dependent&lt;/code&gt; scope with a view. Usable in EL with name &lt;code&gt;loginAction&lt;/code&gt;. It has &lt;code&gt;LoginAction&lt;/code&gt; in its bean types.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;It’s &lt;code&gt;javax.ejb.Singleton&lt;/code&gt; defining a singleton session bean.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;The EJB will be instantiated at startup triggering instantiation of MyBean CDI bean.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;producers&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#producers&quot;&gt;&lt;/a&gt;Producers&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Producers are the way to transform standard pojo into CDI bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A producer can only be declared in an existing bean through field or method definition.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;By adding the &lt;code&gt;@Produces&lt;/code&gt; annotation to a field or a non void method you declare a new producer and so a new Bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Field or method defining a producer may have any modifier or even be static.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Producers behave like standard managed bean:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;they have qualifiers,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;they have scope,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;they can inject other beans: parameters in producer method are injection points that the container will satisfied when it will call the method to produce a contextual instance
      This injection points are still checked at deployment time.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Yet, producers have limitation compared to managed or session bean as &lt;strong&gt;they don’t support interceptors or decorators&lt;/strong&gt;.
      You should keep this in mind when creating them as this limitation is not obvious when reading the spec.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;If your producer (field or method) can take the null value you must put in in &lt;code&gt;@Dependent&lt;/code&gt; scope.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Remember the &lt;code&gt;Bean&amp;lt;T&amp;gt;&lt;/code&gt; interface we talked above ?
      You can see a producer method as a convenient way to define the &lt;code&gt;Bean.create()&lt;/code&gt; method, even if it’s a bit more complicated.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;So if we can define &lt;code&gt;create()&lt;/code&gt; what about &lt;code&gt;destroy()&lt;/code&gt;?
      It’s also available with disposers methods.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;disposers&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#disposers&quot;&gt;&lt;/a&gt;Disposers&lt;/h4&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A less known feature of producer is the possibility to define a matching disposer method.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A disposer method allows the application to perform customized cleanup of an object returned by a producer method or producer field.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Like producers, disposers methods must be define in a CDI bean, can have any modifier and even be static.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Unlike producer they should have one and only one parameter, called the disposer parameter and annotated with &lt;code&gt;@Disposes&lt;/code&gt;.
      When the container container finds producer method or field, it looks for matching disposer method.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;More than one producer can match to one disposer method.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;bean-types-of-a-producer&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#bean-types-of-a-producer&quot;&gt;&lt;/a&gt;Bean types of a producer&lt;/h4&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It depends of the type of the producer (field type or method returned type):&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;If it’s an interface, the bean type set will contain the interface all interface it extends (directly or indirectly) and &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;If it’s a primitive or array type, the set will contain the type and &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;If it’s a class, the set will contains the class, every superclass and all interface it implements (directly or indirectly).&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Again, &lt;code&gt;@Typed&lt;/code&gt; can restrict the bean types of the producer.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;examples-2&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#examples-2&quot;&gt;&lt;/a&gt;Examples&lt;/h4&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ProducerBean {
      
        @Produces
        @ApplicationScoped
        private List&amp;lt;Integer&amp;gt; mapInt = new ArrayList&amp;lt;&amp;gt;(); &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      
        @Produces @RequestScoped @UserDatabase
        public EntityManager create(EntityManagerFactory emf) { &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
          return emf.createEntityManager();
        }
      
        public void close(@Disposes @Any EntityManager em) {  &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
          em.close();
        }
      
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;This producer field defines a bean with Bean types &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;, &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt;, &lt;code&gt;Iterable&amp;lt;Integer&amp;gt;&lt;/code&gt; and `Object&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;This producer method defines a &lt;code&gt;EntityManager&lt;/code&gt; with &lt;code&gt;@UserDatabase&lt;/code&gt; qualifier in &lt;code&gt;@RequestScoped&lt;/code&gt; from an &lt;code&gt;EntityManagerFactory&lt;/code&gt; bean produced elsewhere.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;This disposer disposes all produced &lt;code&gt;EntityManager&lt;/code&gt; (thanks to &lt;code&gt;@Any&lt;/code&gt; qualifier)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;resources&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#resources&quot;&gt;&lt;/a&gt;Resources&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Thanks to producer mechanism CDI allows to expose Java EE resources as CDI Bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;These resources are:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;persistence context (&lt;code&gt;@PersistenceContext&lt;/code&gt;),&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;persistence unit (&lt;code&gt;@PersistenceUnit&lt;/code&gt;),&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;remote EJB (&lt;code&gt;@EJB&lt;/code&gt;),&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;web service (&lt;code&gt;@WebServiceRef&lt;/code&gt;), and&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;generic Java EE resource (&lt;code&gt;@Resource&lt;/code&gt;).&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;To declare a resource bean you only have to declare a producer field in a existing CDI bean&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;title&quot;&gt;Declaring resources beans&lt;/div&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Produces
      @WebServiceRef(lookup=&quot;java:app/service/PaymentService&quot;) &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
      PaymentService paymentService;
      
      @Produces
      @EJB(beanname=&quot;../their.jar#PaymentService&quot;) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      PaymentService paymentService;
      
      @Produces
      @CustomerDatabase
      @PersistenceContext(unitName=&quot;CustomerDatabase&quot;) &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
      EntityManager customerDatabasePersistenceContext;
      
      @Produces
      @CustomerDatabase
      @PersistenceUnit(unitName=&quot;CustomerDatabase&quot;) &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
      EntityManagerFactory customerDatabasePersistenceUnit;
      
      @Produces
      @CustomerDatabase
      @Resource(lookup=&quot;java:global/env/jdbc/CustomerDatasource&quot;) &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
      Datasource customerDatabase;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;colist arabic&quot;&gt;
      &lt;table&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;producing a webservice from its JNDI name&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;producing a remote EJB from its bean name&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;producing a persistence context from a specific persistence unit with &lt;code&gt;@CustomerDatabase&lt;/code&gt; qualifier&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;producing a a specific persistence unit with &lt;code&gt;@CustomerDatabase&lt;/code&gt; qualifier&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;producing a Java EE resource from its JNDI name&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Of course you can expose the resource in more complex way:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;title&quot;&gt;producing an &lt;code&gt;EntityManager&lt;/code&gt; with &lt;code&gt;COMMIT&lt;/code&gt; flush mode&lt;/div&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class EntityManagerBeanProducer {
      
        @PersistenceContext
        private EntityManager em;
      
        @Produces
        EntityManager produceCommitEm() {
          em.setFlushMode(COMMIT);
          return em;
        }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;After declaration resources bean can be injected as any other bean.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect3&quot;&gt;
      &lt;h4 id=&quot;bean-type-of-a-resource&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#bean-type-of-a-resource&quot;&gt;&lt;/a&gt;Bean type of a resource&lt;/h4&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Resources exposed as bean with producer follow the same rules than producers regarding their type set.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;built-in-beans&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#built-in-beans&quot;&gt;&lt;/a&gt;Built-in beans&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Beyond beans you can create or expose, CDI provides a lot of built-in beans helping you in your development&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;First the container should always provide built-in beans with &lt;code&gt;@Default&lt;/code&gt; qualifier for the following interfaces:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;BeanManager&lt;/code&gt; in &lt;code&gt;@Dependent&lt;/code&gt; scope,to allow injection of BeanManager in an bean,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;Conversation&lt;/code&gt; in &lt;code&gt;@RequestScoped&lt;/code&gt; to allow management of the conversation scope.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;To allow the use of events and programmatic lookup, the container must also provide built-in beans for with:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;Event&amp;lt;X&amp;gt;&lt;/code&gt; in its set of bean types, for every Java type &lt;code&gt;X&lt;/code&gt; that does not contain a type variable,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;every event qualifier type in its set of qualifier types,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;scope &lt;code&gt;@Dependent&lt;/code&gt;,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;no bean name.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For programmatic lookup the container must provide a built-in bean with:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;Instance&amp;lt;X&amp;gt;&lt;/code&gt; and &lt;code&gt;Provider&amp;lt;X&amp;gt;&lt;/code&gt; for every legal bean type &lt;code&gt;X&lt;/code&gt; in its set of bean types,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;every qualifier type in its set of qualifier types,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;scope &lt;code&gt;@Dependent&lt;/code&gt;,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;no bean name.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A Java EE or embeddable EJB container must provide the following built-in beans, all of which have qualifier &lt;code&gt;@Default&lt;/code&gt;:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;a bean with bean type &lt;code&gt;javax.transaction.UserTransaction&lt;/code&gt;, allowing injection of a reference to the JTA &lt;code&gt;UserTransaction&lt;/code&gt;, and&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;a bean with bean type &lt;code&gt;java.security.Principal&lt;/code&gt;, allowing injection of a &lt;code&gt;Principal&lt;/code&gt; representing the current caller identity.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A servlet container must provide the following built-in beans, all of which have qualifier &lt;code&gt;@Default&lt;/code&gt;:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;a bean with bean type &lt;code&gt;javax.servlet.http.HttpServletRequest&lt;/code&gt;, allowing injection of a reference to the &lt;code&gt;HttpServletRequest&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;a bean with bean type &lt;code&gt;javax.servlet.http.HttpSession&lt;/code&gt;, allowing injection of a reference to the &lt;code&gt;HttpSession&lt;/code&gt;,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;a bean with bean type &lt;code&gt;javax.servlet.ServletContext&lt;/code&gt;, allowing injection of a reference to the `ServletContext&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Finally to allow introspection of dependency injection and AOP, the container must also provide the built-in bean in &lt;code&gt;@Dependent&lt;/code&gt; scope for the following interfaces when a an existing bean inject them:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;InjectionPoint&lt;/code&gt; with &lt;code&gt;@Default&lt;/code&gt; qualifier to get information about the injection point of a &lt;code&gt;@Dependent&lt;/code&gt; bean,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;Bean&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;@Default&lt;/code&gt; qualifier to inject in a Bean having &lt;code&gt;T&lt;/code&gt; in its typeset,&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;Bean&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;@Intercepted&lt;/code&gt; or &lt;code&gt;@Decorated&lt;/code&gt; qualifier to inject in an interceptor or decorator applied on
      Interceptor and Decorator for a bean having T in its typeset.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Check the spec on &lt;a href=&quot;http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#bean_metadata&quot;&gt;bean metadata&lt;/a&gt; to get all the restriction regarding &lt;code&gt;Bean&lt;/code&gt; injection.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;custom-beans&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#custom-beans&quot;&gt;&lt;/a&gt;Custom beans&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI gives you even more with Custom beans.
      Thanks to portable extension you can add your own kind bean allowing you to hook on the instantiation, injection and destruction of the instances.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;You could for instance look in a registry to check for a given instance instead of instantiating the object.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;I’ll show you on a coming post how to create such a bean in a portable extension.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;As you see there are a lot of things happening behind the &lt;code&gt;@Inject&lt;/code&gt; scene.
      Understanding them will help you to make a better use of CDI and give you a clearer entry point to Portable extension&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    </content>
  </entry>
  <entry>
    <id>http://www.next-presso.com/2014/06/you-think-you-know-everything-about-cdi-events-think-again.html</id>
    <title>You think you know everything about CDI events… Think again!</title>
    <updated>2017-02-07T16:51:38+01:00</updated>
    <published>2014-06-10T00:00:00+00:00</published>
    <link href="http://www.next-presso.com/2014/06/you-think-you-know-everything-about-cdi-events-think-again.html" rel="alternate" type="text/html" />
    <category term="CDI"></category>
    <summary>
      Event Bus may surprise you
      
      
      CDI events are one of the shiniest feature in the CDI specification. They are a easy to understand and use and are a straight forward implementation of the Observer Design Pattern. To sum up they add more decoupling to the Dependency Injection by allowing notification of unknown target at development time (great to develop framework). Yet, documentation about event is often misleading and contains inaccurate information, probably due to the fact that the specification was wrong before we corrected it for CDI 1.2 release ;). This post is the opportunity to update or clarify your knowledge...
    </summary>
    <content type="html">
      &lt;div id=&quot;preamble&quot;&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;imageblock&quot; style=&quot;float: left&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/posts/2014/Event-bus.jpg&quot; alt=&quot;Event bus&quot; width=&quot;310&quot; /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;title&quot;&gt;Event Bus may surprise you&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI events are one of the shiniest feature in the CDI specification. They are a easy to understand and use and are a straight forward implementation of the Observer Design Pattern. To sum up they add more decoupling to the Dependency Injection by allowing notification of unknown target at development time (great to develop framework). Yet, documentation about event is often misleading and contains inaccurate information, probably due to the fact that the specification was wrong before we corrected it for CDI 1.2 release ;). This post is the opportunity to update or clarify your knowledge  about how events work in CDI 1.0  and 1.1+ and what could come in CDI 2.0.
      If you want to “play” with event you can checkout my Github project EventsTest to use it as a sandbox.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;If you are familiar with events you can directly go to the more advanced or less know features&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;back-to-the-basics&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#back-to-the-basics&quot;&gt;&lt;/a&gt;Back to the basics&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Before going further, let’s introduce basic concepts around CDI events.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;what-s-an-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#what-s-an-event&quot;&gt;&lt;/a&gt;What’s an event?&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI events are defined by 2 things :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;A java object (the event object)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;A set of qualifiers (annotations having the meta annotation @Qualifier)
      The event Object could be of any Java type and don’t have to be CDI related (try to avoid using bean instance as event object, it’s confusing and if the bean scope is not @Dependent could bring issues related to bean lifecycle). Qualifiers are the same used to define CDI Bean or injection point. They can have members or not. And their members value are part of the qualifier definition or not (if they have the @NonBinding annotation).&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;how-to-fire-an-event&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#how-to-fire-an-event&quot;&gt;&lt;/a&gt;How to fire an event?&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The most universal way to fire an event is to use the BeanManager.fireEvent(Object event,Annotation…​ qualifiers) method. BeanManger is directly accessible in CDI bean by injecting it:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Inject
      BeanManager beanManager;
      
      public void doSomething() {
        beanManager.fireEvent(new Payload());
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Outside CDI you can alway retrieve it by JNDI (by looking up for “java:comp/BeanManager” name)or more easily in CDI 1.1+ via CDI class:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;BeanManager beanManager = CDI.current().getBeanManager();
      
      public void doSomething() {
        beanManager.fireEvent(new Payload());
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In CDI bean, it is more common and natural to use the Event&amp;lt;T&amp;gt; interface to get possibility to fire an event like this:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Inject
      Event&amp;lt;Payload&amp;gt; payloadEvent;
      
      public void doSomething() {
        payloadEvent.fire(new Payload());
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The &lt;code&gt;Event&amp;lt;T&amp;gt;&lt;/code&gt; interface is an helper to fire event whose type is totally CDI agnostic and thus doesn’t include a way of being fired. To make a gun fire analogy, In the previous example, see payloadEvent as the bullet case while the bullet is the instance of Payload you gave as parameter of the fire() method.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;observing-events&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#observing-events&quot;&gt;&lt;/a&gt;Observing events&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;To observe an event you’ll have to add an observer method in an enable bean of your application. An observer method is a method whose first parameter has the @Observes annotation. The type of the parameter with @Observes will be used to resolve target observer when an event is fired as we’ll see later. So:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void listenToPayload(@Observes Payload event) {
        ...
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;will be triggered (if the method is in an active bean) for all events whose type are Payload or a super type of Payload. Off course qualifier may be added to the observer to restrict event triggering:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void listenToPayload(@Observes @Qualified Payload event) {
        ...
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The observers resolution occurs at runtime when an event is fired. All the observers that match the event will be triggered by the CDI container. Note that the observer method may have other beans as parameters. They will be injected by the container before calling the method :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void listenToPayload(@Observes Payload event, PayloadService service) {
        ...
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;features-you-may-have-missed-regarding-cdi-events&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#features-you-may-have-missed-regarding-cdi-events&quot;&gt;&lt;/a&gt;Features you may have missed regarding CDI events&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The following CDI events feature are less known or badly documented.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;no-type-erasure-for-event-type&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#no-type-erasure-for-event-type&quot;&gt;&lt;/a&gt;No type erasure for event type&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It’s not an hidden feature but more something implicit in CDI than can be missed. As CDI is a type centric specification (I always sigh when I see and injection point with a @Name qualifier), it does a better job than standard Java regarding parameterized type.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For instance take these 2 observer methods:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void processNumberList(@Observes List&amp;lt;Number&amp;gt; event) {
        ...
      }
      
      public void processIntegerList(@Observes List&amp;lt;Integer&amp;gt; event) {
        ...
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The container will make the distinction between both when resolving observer depending of the parameterized type of the event.  And in CDI 1.1+ (wildcards are not allowed in observer event parameter in CDI 1.0) if you declare the following observers :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void processIntegerList(@Observes List&amp;lt;? super Integer&amp;gt; event) {
      ...
      }
      
      public void processNumberList(@Observes List&amp;lt;? extends Number&amp;gt; event) {
      ...
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Both will be called if your event type is List&amp;lt;Integer&amp;gt; or List&amp;lt;Number&amp;gt;. Although the first observer will fit for add elements to the list while the second will be used to fetch elements from the list.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Remember that if wildcards are allowed in observer in CDI 1.1+ if they aren’t in Event injection point.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;qualifiers-don-t-work-with-event-as-they-work-with-beans&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#qualifiers-don-t-work-with-event-as-they-work-with-beans&quot;&gt;&lt;/a&gt;Qualifiers don’t work with event as they work with beans&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;That’s an important point that was very badly explained in the spec before CDI 1.2. Developers often assume that Event&amp;lt;&amp;gt; and Instance&amp;lt;&amp;gt; have quite similar way of functioning regarding qualifiers, that’s a big mistake. But let’s start with the most important here :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;An observer matches an event if its type is in the event types set and if the observer has a subset of the qualifier of the event.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Better check this with a piece of code&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/**
       * Qualifier with binding member
       */
      @Qualifier
      @Target({TYPE, METHOD, PARAMETER, FIELD})
      @Retention(RUNTIME)
      @Documented
      public @interface Qualified {
          String value() default &quot;&quot;;
      }
      
      public class EventTestService {
      
          @Inject
          @Qualified(&quot;strong&quot;)
          Event&amp;lt;Payload&amp;gt; payLoadEvent;
      
          public void fireEvent() {
            payloadEvent.fire(new Payload());
          }
      
          public void processUnqualifiedPayload(@Observes Payload event) {}
      
          public void processQualifiedPayload(@Observes @Qualified(&quot;strong&quot;) Payload event) {}
      
          public void processUnqualifiedObject(@Observes Object event) {}
      
          public void processQualifiedObject(@Observes @Qualified(&quot;strong&quot;) Object event) {}
      
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Yes, all the 4 declared observers will be called by the container when the event is fired. Useful to know that ;).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;So &lt;code&gt;@Any&lt;/code&gt; qualifier is totally useless on events or observers&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The spec requires that all created events should have the &lt;code&gt;@Any&lt;/code&gt; automatically added, but as we just saw &lt;code&gt;@Any&lt;/code&gt; has the same behavior in event that @Default qualifier (no qualifier), so prefer using no qualifier instead of using @Any, it’ll be less confusing.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;code&gt;Event&amp;lt;&amp;gt;&lt;/code&gt; is here to build events not filter them&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Again &lt;code&gt;Event&lt;/code&gt; looks like &lt;code&gt;Instance&lt;/code&gt; but is very different. While &lt;code&gt;Instance&lt;/code&gt; is a tool to lookup for beans, &lt;code&gt;Event&lt;/code&gt; is a tool to build an event from an object and qualifiers.
      So keep in mind that when you use &lt;code&gt;Event.select(Annotation... qualifiers)&lt;/code&gt; you are adding qualifier to the event you’ll be firing.
      For instance :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class EventTestService {
      
          @Inject
          @MyQualifier
          Event&amp;lt;Payload&amp;gt; payLoadEvent;
      
          public void fireEvent() {
            payloadEvent.select(new QualifiedLiteral()).fire(new Payload());
          }
      }
      
      public class QualifiedLiteral extends AnnotationLiteral&amp;lt;Qualified&amp;gt; implements Qualified {
      
          private String value=&quot;&quot;;
      
          public QualifiedLiteral(String value) {
              this.value = value;
          }
      
          public QualifiedLiteral() {
              this(&quot;&quot;);
          }
      
          public String value() {
              return value;
          }
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;will add the &lt;code&gt;@Qualified&lt;/code&gt; qualifier to the event before firing it. So the final event will have &lt;code&gt;@MyQualifier @Qualified(&quot;&quot;)&lt;/code&gt; qualifiers.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;advanced-event-features&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#advanced-event-features&quot;&gt;&lt;/a&gt;Advanced Event Features&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;conditional-observer-methods&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#conditional-observer-methods&quot;&gt;&lt;/a&gt;Conditional Observer methods&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;As we saw, observer methods have to be in a bean to be registered by the container. If the bean containing the observer has a different scope than @Dependent we may want to control if the call to the observer should trigger bean instantiation.
      You can do that with the receive member of @Observes annotation which can take the enum values javax.enterprise.event.Reception.ALWAYS (by default) or javax.enterprise.event.Reception.IF_EXISTS.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@RequestScoped
      public class EventTestService {
      
          // will always be called (bean my be instantiated for this call)
          public void processQualifiedPayload(@Observes(receive=ALWAYS) Type1 event) {}
      
          // will be called only if the bean already exists in Request scope
          public void processUnqualifiedPayload(@Observes(receive=IF_EXISTS) Type2 event) {}
      
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Remember that IF_EXISTS cannot be used in a bean having @Dependent scope since the bean cannot exists before observer is called. If you do the mistake the container will remember you that at startup.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;transactional-observer-methods&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#transactional-observer-methods&quot;&gt;&lt;/a&gt;Transactional observer methods&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Transactional observer methods are observer methods which receive event notifications during the before or after completion phase of the transaction in which the event was fired. If no transaction is in progress when the event is fired, they are notified at the same time as other observers.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;A before completion observer method is called during the before completion phase of the transaction.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;An after completion observer method is called during the after completion phase of the transaction.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;An after success observer method is called during the after completion phase of the transaction, only when the transaction completes successfully.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;An after failure observer method is called during the after completion phase of the transaction, only when the transaction fails.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;You can specify the transaction phase of the observer call with the during member of the &lt;code&gt;@Observes&lt;/code&gt; annotation.
      The enumeration &lt;code&gt;javax.enterprise.event.TransactionPhase&lt;/code&gt; identifies the kind of transactional observer method the enum values are:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;IN_PROGRESS: default value
      BEFORE_COMPLETION
      AFTER_COMPLETION
      AFTER_FAILURE
      AFTER_SUCCESS
      For instance:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@RequestScoped
      public class EventTestService {
      
          // is called when the event is fired
          public void processCustomerUpdateRequest(@Observes(during=IN_PROGRESS) @Updated customer cust) {}
      
          // is called by the same event fired than previous observer but only after the trnsaction complete successufully
          public void processCustomerUpdated(@Observes(during=AFTER_SUCCESS) @Updated customer cust) {}
      
      }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Note that the transaction observer mechanism is the only way to differ and order some observer right now.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;built-in-events-linked-to-scope-lifecycle-cdi-1-1&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#built-in-events-linked-to-scope-lifecycle-cdi-1-1&quot;&gt;&lt;/a&gt;Built-in events linked to scope lifecycle (CDI 1.1+)&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Since CDI 1.1, the container fire events when context are created and destroyed, thanks to the provided @Intialized and @Destroyed qualifiers.
      If your application is deployed in a servlet container, the event payload correspond to the servlet scope object corresponding to the initialized or destroyed CDI scope. Otherwise payload will be java.lang.object
      You can observe these event in your application like this (if it’s deployed in a servlet container) :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void processApplicationScopedInit(@Observes @Initialized(ApplicationScoped.class) ServletContext payload) {}
      
      public void processApplicationScopedDestroyed(@Observes @Destroyed(ApplicationScoped.class) ServletContext payload) {}
      
      public void processSessionScopedInit(@Observes @Initialized(SessionScoped.class) HttpSession payload) {}
      
      public void processSessionScopedDestroyed(@Observes @Destroyed(SessionScoped.class) HttpSession payload) {}
      
      public void processRequestScopedInit(@Observes @Initialized(RequestScoped.class) ServletRequest payload) {}
      
      public void processRequestScopedDestroyed(@Observes @Destroyed(RequestScoped.class) ServletRequest payload) {}
      
      public void processConversationScopedInit(@Observes @Initialized(ConversationScoped.class) ServletRequest payload) {}
      
      public void processConversationScopedDestroyed(@Observes @Destroyed(ConversationScoped.class) ServletRequest payload) {}&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Specification encourage third party extension to do the same for custom context.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;events-metadata-cdi-1-1&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#events-metadata-cdi-1-1&quot;&gt;&lt;/a&gt;Events Metadata (CDI 1.1+)&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Version 1.1 of the spec introduced EventMetadata interface. It allows an observer to get all the metadata about an event.
      You get the EventMetadata by adding it to the observer parameters :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void processPayload(@Observes Payload event, EventMetadata meta) {}&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The EventMetadata contains the following methods:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;getQualifiers() returns the set of qualifiers with which the event was fired.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;getInjectionPoint() returns the InjectionPoint from which this event payload was fired, or null if it was fired from BeanManager.fireEvent(…).&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;getType() returns the type representing runtime class of the event object with type variables resolved.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This bring a solution to add more fine-grained filtering on observer execution depending on actual metadata of the triggered event&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;events-limitation&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#events-limitation&quot;&gt;&lt;/a&gt;Events limitation&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Right now, CDI events have two big limitation out of the box&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;events-are-only-synchronous&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#events-are-only-synchronous&quot;&gt;&lt;/a&gt;Events are only synchronous&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Out of the box events are synchronous: method firing an event has to wait the end of all observers invocation before executing instruction after event firing. So no fire and forget option and off course no callback approach.
      The obvious solution if you need asynchronous event approach is to use an EJB method as an observer and annotate it @Asynchronous. Other options exists but you need to create a CDI portable extension and play with threads. I’ll try to explore that in a future post.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;observers-have-no-orders&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#observers-have-no-orders&quot;&gt;&lt;/a&gt;Observers have no orders&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Yes, there’s no out of the box solution to guarantee order of observers execution. The only tiny exception is using transaction phase to do so but it’s very limited. Perhaps a CDI extension could help us here again. I’ll try to explore this approach in a future post.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;pattern-and-tips-with-events&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#pattern-and-tips-with-events&quot;&gt;&lt;/a&gt;Pattern and tips with events&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Putting all the knowledge we have now on event and other CDI stuff we can figure out some interesting pattern for our developement.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;the-plugin-pattern&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#the-plugin-pattern&quot;&gt;&lt;/a&gt;The plugin Pattern&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;We saw that CDI event data is totally free. You can choose any object (again avoid no dependent bean) to fire an event and this object will be received as a playlod by each observer matching the event type and qualifier.
      An other interesting fact is that this payload is mutable and can be modified by its observers. Following this idea, observers can become a way to enrich a given object with new data. We can use this approach to seamlessly enhance content by adding a CDI archive to an existing application.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;the-catch-them-all-pattern&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#the-catch-them-all-pattern&quot;&gt;&lt;/a&gt;The catch them all pattern&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Need to observe all fired event and have their info (for logging purpose for instance), you only have to observe Object.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public void processPayload(@Observes Object event, EventMetadata meta) {}&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;EventMetadata will even help you to know in which bean the event was fired. A nice way to build a bridge with a messaging service (did I say JMS? ;) )&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;don-t-forget-interceptors-and-decorators&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#don-t-forget-interceptors-and-decorators&quot;&gt;&lt;/a&gt;Don’t forget Interceptors and Decorators&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;While it’s forbidden to declare observer in decorators or interceptors, you can still fire event from them. So they can be used to enhance existing bean and add event triggering to them without touching their code.
      A nice way to add event notification only when needed.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;future-for-cdi-events&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#future-for-cdi-events&quot;&gt;&lt;/a&gt;Future for CDI events&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;We have a lot of idea in CDI 2.0 regarding event enhancement. Off course adding observer priority and asynchronous treatment are on the top of the list. On asynchronous event we could even think of adding callback method support based on java.lang.invoke package.
      More ambitious ideas are floating around like giving a range to events making them cross the War or Ear barrer and spread across the server or the cluster. That could lead us to provide an event bus at the server level and help java EE to adopt new application architectures in the future  EE versions.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    </content>
  </entry>
  <entry>
    <id>http://www.next-presso.com/2014/03/forward-cdi-2-0.html</id>
    <title>Forward CDI 2.0</title>
    <updated>2017-02-07T16:51:38+01:00</updated>
    <published>2014-03-15T00:00:00+00:00</published>
    <link href="http://www.next-presso.com/2014/03/forward-cdi-2-0.html" rel="alternate" type="text/html" />
    <category term="CDI"></category>
    <summary>
      CDI is probably one of most overlooked specification in Java EE, yet when version 1.0 was released 4 years ago it was presented as “Java EE extension point”. Technically it’s the case, but for all kind of reason some JSR didn&#8217;t adopt CDI totally to provide a more consistent experience in Java EE. Today the IT world is moving fast and after long years of heavy memory and process solution we’re going back to resource optimization with mobile or embedded platform. As CDI can leave outside Java EE, it could play an interesting role in this new approach. But before...
    </summary>
    <content type="html">
      &lt;div id=&quot;preamble&quot;&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;span class=&quot;image&quot; style=&quot;float: left&quot;&gt;&lt;img src=&quot;http://www.next-presso.com/images/posts/2014/back-to-the-future.jpg&quot; alt=&quot;back to the future&quot; width=&quot;200&quot; /&gt;&lt;/span&gt;
      CDI is probably one of most overlooked specification in Java EE, yet when version 1.0 was released 4 years ago it was presented as “Java EE extension point”. Technically it’s the case, but for all kind of reason some JSR didn’t adopt CDI totally to provide a more consistent experience in Java EE. Today the IT world is moving fast and after long years of heavy memory and process solution we’re going back to resource optimization with mobile or embedded platform. As CDI can leave outside Java EE, it could play an interesting role in this new approach. But before that it should evolve to be ready for this new challenge (and continue to pursue its growing role in Java EE as well) In this post I’ll try to share my ideas on how  CDI should evolve to meet it future rendez-vous. So I’ll start by exposing the new feature I’d like to see in CDI before exploring a more modular architecture for the spec to make it scalable from Raspberry  Pi to Huge cluster solutions.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;em&gt;Disclaimer : Since I’ll be leading CDI 2.0 specification (with Pete Muir) it’s important to stress that this post is not an official announcement about the content of the CDI 2.0 specification. It’s only my thought and doesn’t engage CDI Expert Group or Red Hat.&lt;/em&gt;&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;new-features-i-d-like-to-have&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#new-features-i-d-like-to-have&quot;&gt;&lt;/a&gt;New features I’d like to have&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Some of these features are already in the Expert Group pipeline, some were deferred during CDI 1.1 for CDI 2.0, some are standardisation of third party development (mainly &lt;a href=&quot;http://deltaspike.apache.org&quot; target=&quot;_blank&quot;&gt;Apache Deltaspike&lt;/a&gt;) and some are totally new. Anyway, most of these point are important to help third party project or JSR to get the best of CDI.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;java-se-bootstrapping&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#java-se-bootstrapping&quot;&gt;&lt;/a&gt;Java SE Bootstrapping&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;I don’t need to insist on this point. Today each implementation provide a way to bootstrap CDI in Java SE or in a poor server (Servlet only) environnement. Apache Deltaspike has a generic solution to do it. So it’s time that the CDI spec integrates this to be officially available in Java SE.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;container-hot-swap&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#container-hot-swap&quot;&gt;&lt;/a&gt;Container hot swap&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Strong typed injection is great, but CDI is too strict on this in my opinion. To support dynamic JVM language, we should be able to trigger a BeanManager restart with runtime added bean. this could be done for instance by providing API for bootstrapping a new CDI container with augmented content. If the boot went well have more step to duplicate status and existing instance in the new container and garbage the old one. In case of error we could keep the existing BeanManager. A costly but very useful feature for advanced tools or app that could provide specific enhancement system (CMS, e-commerce platform, etc…).&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;cdi-lite&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#cdi-lite&quot;&gt;&lt;/a&gt;CDI lite&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;As said in my introduction, there’s a shared wish to bring CDI to embedded devices like Raspberry pi, Arduino, Lego Mindstorms or Android. Today the massive uses of proxies in implementations prevent us to go in that direction.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Java Proxies were very useful in the 2000’s, but now they begin to be old fashioned and brings a lot of problem (huge stack trace, JVM optimization, High resource consumption, etc…). Right now CDI spec take for granted that proxies will be used in implementations.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;For this reason, it could be a good solution to provide a subset of CDI specification with less magic and less weight. Let’s call it “CDI Lite” (like EJB Lite that were introduced in Java EE 6). This CDI subset would keep all the DI stuff but would probably get rid of all the Context part as well as Interceptor and Decorator.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;But there are others tracks that could be explored to make CDI lighter without removing some of its features.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;bye-bye-proxy-hello-annotation-processing-and-invokedynamic&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#bye-bye-proxy-hello-annotation-processing-and-invokedynamic&quot;&gt;&lt;/a&gt;Bye bye Proxy, hello Annotation Processing and InvokeDynamic&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This other way is to find solution to replace proxies by something else in CDI implementations. Right now we have two candidates :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;Annotation Processing : process Annotation at compile time to produce the “magic” injection/injected/decorated code in a static way like it’s done in &lt;a href=&quot;http://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;InvokeDynamic : Runtime linking could provide a proxy-like behavior with less drawbacks and probably more performances. Regarding this second approach I started to do some researches and hope provide a proof of concept soon.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;xml-config-file&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#xml-config-file&quot;&gt;&lt;/a&gt;XML config file&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It’s time to provide this feature in the spec. There use to be extensions out there that provide this feature, but this is a core feature allowing bean registering and annotation overloading at deploy time and it should be in the spec. If CDI could become more and more present in the other spec, it could also be the beginning of a universal Java EE config file format !&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Today, some framework like Apache Camel cannot use CDI because there is no config solution. Providing a solution on that point would ease CDI adoption.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;asynchronous-event-action&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#asynchronous-event-action&quot;&gt;&lt;/a&gt;Asynchronous event / action&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;At the vert.x and node.js era we definitely should support asynchronous treatment (and let’s dream : call back). This could be done By using concurrency spec. We would provide a way to support asynchronous call without using EJB and asynchronous event by adding a boolean asynchronous field in @Observes and, optionally, a handle on a callback&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;support-of-startup&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#support-of-startup&quot;&gt;&lt;/a&gt;Support of @Startup&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;An easy feature to add : provide a way to have a CDI bean automatically instantiated after the initialization phase like we already have in EJB.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It’s a very common request by developers and it’s not very hard to provide.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;portable-extension-spi-promotion-usage-simplification&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#portable-extension-spi-promotion-usage-simplification&quot;&gt;&lt;/a&gt;Portable Extension SPI promotion / usage simplification&lt;/h3&gt;
      &lt;div class=&quot;imageblock&quot; style=&quot;float: right&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;img src=&quot;http://www.next-presso.com/images/posts/2014/CDI-Lifecycle.png&quot; alt=&quot;CDI Lifecycle&quot; width=&quot;450&quot; /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;title&quot;&gt;CDI 1.1 container initialization and Lifecycle&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Portable Extension is, in my opinion, the best feature in CDI. Off course IoC, events or context management are great but they weren’t new when introduced in CDI 1.0.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Portable extension is a complete CDI innovation, that added to Java EE DNA the possibility to be naturally extended without using proprietary tricks.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;In my opinion it’s a pity that Portable Extension were not more promoted (CDI acronym doesn’t include any idea of their existence for instance) and were placed at the end of our specification document since a lot of projects or other specification could benefit from it.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;My analyze is that this lack of communication is linked to the bunch of more or less complexe concepts (like the container initialization events shown in the right side schema) to understand before being able to deep dive into extension development. We should probably provide a higher simplified layer to get started with basic task on extension. Don’t misunderstand me, the existing mechanism is great and should be kept (with probably some enhancement) but we should provide helpers to ease extension creation. These helper could be :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;Standardization of Deltaspike &lt;code&gt;AnnotatedTypeBuilder&lt;/code&gt; and &lt;code&gt;BeanBuilder&lt;/code&gt; to ease new Beans creation&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Helpers on introspection tools regarding types or annotation manipulation&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Easier way to create new scopes or extend existing ones. We encourage other spec to extend lifecycle of existing scopes (like @RequestScoped for Websocket) but it’s nearly impossible to do it without going at the implementation level.&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;We should also bring a special attention to the first events (until AfterTypeDiscovery) in this initialization process, since they are CDI agnostic dealing only with type and annotation metadata modification. These could become part of a future Java EE configuration system.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;ordering-event-execution&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#ordering-event-execution&quot;&gt;&lt;/a&gt;Ordering event execution&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;So in CDI 1.1 decorator and interceptor are ordered thanks to @Priority. What about ordering events ? Using @Priority on @Observes doesn’t seem a good idea since this annotation comes from the interceptor package, but we could add an int priority field in @Observes.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;no-more-segregation-for-producers-and-custom-beans&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#no-more-segregation-for-producers-and-custom-beans&quot;&gt;&lt;/a&gt;No more segregation for Producers and Custom beans&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Why produced bean or custom bean should be CDI second class citizen? I want to be able to decorate or use interceptor on my produced beans or at least have APIs that allow me to add this features to my produced beans.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;event-scoping-from-package-to-server-wide&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#event-scoping-from-package-to-server-wide&quot;&gt;&lt;/a&gt;Event scoping from package to server wide&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Having the CDI event bus at a higher level in Java EE would allow scoping our event. Soone could decide if the event should stay in the current application, be restricted to the current module (in an EAR) even the current package or on the other side be broadcasted to all app listening to it.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;transient-injection&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#transient-injection&quot;&gt;&lt;/a&gt;Transient injection&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;When injecting dependent bean in a longer living bean, this injection is done once when the longer bean is instantiated. There are use cases (I’ve got one in Agorava) where I want my dependent bean to be re-injected each times it’s accessed. Today I have to write :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Inject Instance&amp;lt;MyBean&amp;gt; myBeanInstances;
      public Mybean getMyBean() { return myBeanInstances.get(); }&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Tomorrow I’d like to write this :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Inject @Transient MyBean myBean;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It’s mainly syntaxic sugar but make the code more easy to write and readable. We probably could find other example here of code simplification.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;have-a-more-fluent-programmatic-lookup&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#have-a-more-fluent-programmatic-lookup&quot;&gt;&lt;/a&gt;Have a more fluent programmatic lookup&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The &lt;code&gt;Instance&amp;lt;T&amp;gt;&lt;/code&gt; interface and the programmatic lookup are incredibly useful, but it could be very cumbersome to use especially when we have to deal with Qualifiers.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This could be eased by providing tools to generate qualifier literals  with Java 8 Type Annotations for instance.  And why not a query DSL ?&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;listingblock&quot;&gt;
      &lt;div class=&quot;content&quot;&gt;
      &lt;pre class=&quot;highlightjs highlight nowrap&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;myBeanInstance.restrictedTo(BeanImp.class).withQualifier(new @MyQualifier(&quot;Binding&quot;) AnnotationLiteral&amp;lt;&amp;gt;(), new @MyOtherQualifier AnnotationLiteral&amp;lt;&amp;gt;()).select();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Wouldn’t it be more user friendly ?&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;monitoring-facility&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#monitoring-facility&quot;&gt;&lt;/a&gt;Monitoring facility&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Remember the great debug page in Seam 2 ? I’d like to have the same things or tools to easily build the same feature to monitor my beans and my scope. CDI does a lot of Magic and it could be nice to have tools to see all its trick and the cost of beans, context and other interceptor we deployed&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;give-me-more-modularity-a-new-architecture-for-cdi-and-java-ee&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#give-me-more-modularity-a-new-architecture-for-cdi-and-java-ee&quot;&gt;&lt;/a&gt;Give me more modularity : a new architecture for CDI (and Java EE ?)&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;span class=&quot;image&quot; style=&quot;float: left&quot;&gt;&lt;img src=&quot;http://www.next-presso.com/images/posts/2014/CDI-Next-Architecture.png&quot; alt=&quot;CDI Next Architecture&quot; width=&quot;400&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A lot of JSR complained that CDI spec is too monolithic and that implementations are too heavy comparing to theirs (they don’t want to depend on something bigger). This and the lack of standard Java SE bootstrapping, are probably the 2 mains objection to go for a deep CDI integration in some spec. So we should provide a more modular approach while keeping the possibility to gather all the modules and have a consistent stack that we could use outside Java EE. In my ideal world the different JSR / Modules would be :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;container&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#container&quot;&gt;&lt;/a&gt;Container&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This module store all the beans defined in the application. Providing as a standalone module brings the following features :&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;ulist&quot;&gt;
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;Provides a minimum api/impl for a client app that rely on JNDI to get Beans&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Provides the possibility to add plugins to the container to support new kind of components (Servlet, JPA Entity, Guice or Spring beans for instance)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;Prepare the CDI container to be the future universal Java EE container that we’re waiting for&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;event-bus&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#event-bus&quot;&gt;&lt;/a&gt;Event bus&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Events and observer pattern are great features of CDI spec. But they would be more useful if spec could use them without having to depend on all CDI.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;We could imagine a new Java EE specification or a CDI module based on CDI event API to provide Java EE wide eventing model. We could imagine an API only relying on half a dozen classes (more if we add asynchronous treatment, ordering and event scoping) hat would do the Job.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;component-scanning-extension-engine&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#component-scanning-extension-engine&quot;&gt;&lt;/a&gt;Component Scanning &amp;amp; Extension engine&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Today each specification does class scanning at boot time. In general the app server provides a way to group this scanning process in a proprietary way. By standardizing the scanning phase events and the meta-data manipulated during this scanning phase we could provide a consistent experience and a standard way to extend Java EE. CDI already provides most of this feature with its initialization mechanism which allow to “observe” all wished existing classes in deployment and modify meta-data of these classes (i.e. annotations) .&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Imagine what you could do if the ProcessAnnotatedType event could be catch at the server level and allow you to put a “veto” on a given servlet or on a group of JPA entities? This feature lead us on the single container and the single configuration file path. A feature dreamt by a lot of developers.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;basic-di&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#basic-di&quot;&gt;&lt;/a&gt;Basic DI&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This module would include all API related to simple injection (only pseudo-scope). So all &lt;code&gt;@Inject&lt;/code&gt;, &lt;code&gt;@Qualifier&lt;/code&gt;, &lt;code&gt;Instance&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;@Producer&lt;/code&gt;, &lt;code&gt;InjectionPoint&lt;/code&gt; and other Reflection stuff will be gathered in a light API. Probably what I called “CDI lite” in my previous part.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;context-management&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#context-management&quot;&gt;&lt;/a&gt;Context Management&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Context is a nice feature of CDI but as everybody don’t need it, it should be put in a optional API package. This part will deal with all the normal scope context and complex life cycles.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect2&quot;&gt;
      &lt;h3 id=&quot;interceptor-decorator&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#interceptor-decorator&quot;&gt;&lt;/a&gt;Interceptor &amp;amp; Decorator&lt;/h3&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Today interceptors already have their own JSR. Adding decorator to the JSR would complete the interceptor JSR.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;sect1&quot;&gt;
      &lt;h2 id=&quot;conclusion-cdi-needs-you&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#conclusion-cdi-needs-you&quot;&gt;&lt;/a&gt;Conclusion : CDI needs you!&lt;/h2&gt;
      &lt;div class=&quot;sectionbody&quot;&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;So, here’s my personal CDI wish list. You probably have yours (we collected your 3 CDI 2 wishes in december / january, and we intend to use them. If you didn’t send them, feel free to add them in comment of this article). I don’t know if all these point are good ideas (just read the comment to make your opinion). I don’t know if they are all doable (probably not). What I know is that we’ll need all help we can have to work on the future CDI 2.0. So if you want to be part of this adventure, stay tuned on &lt;a href=&quot;http://cdi-spec.org&quot; target=&quot;_blank&quot;&gt;CDI official website&lt;/a&gt;, &lt;a href=&quot;http://twitter.com/cdispec&quot; target=&quot;_blank&quot;&gt;@cdispec&lt;/a&gt; twitter account (or &lt;a href=&quot;http://twitter.com/antoine_sd&quot; target=&quot;_blank&quot;&gt;mine&lt;/a&gt;) and this blog and give us your feedback on &lt;a href=&quot;https://lists.jboss.org/mailman/listinfo/cdi-dev&quot; target=&quot;_blank&quot;&gt;CDI ML&lt;/a&gt; or CDI IRC channel (#jsr346 on freenode). The coming months will be decisive regarding CDI (and Java EE) future.&lt;/p&gt;
      &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    </content>
  </entry>
  <entry>
    <id>http://www.next-presso.com/2011/09/please-jboss-dont-let-cdi-become-the-betamax-of-java-by-destroying-seam-3.html</id>
    <title>Please JBoss don’t let CDI become the « Betamax » of Java by destroying Seam 3</title>
    <updated>2017-02-08T20:33:33+01:00</updated>
    <published>2011-09-30T00:00:00+00:00</published>
    <link href="http://www.next-presso.com/2011/09/please-jboss-dont-let-cdi-become-the-betamax-of-java-by-destroying-seam-3.html" rel="alternate" type="text/html" />
    <category term="CDI"></category>
    <category term="Seam"></category>
    <summary>
      Following the in.relation.to blog post of last tuesday,as a tech lead on one Seam Module (Seam Social),I wrote this open Letter to Red Hat employees in charge of Seam project and community. I find useful to share my point of view with the community on this matter. You also might find interesting to read the blog post of Hannelita on the same subject.
      
      
      Here is my letter:
      
      
      
      
      This email is a tentative to gather and synthesize all my thought following the yesterday announce on in.relation.to about Seam 3 reorganization. I want it to be seen as a positive feedback. I don’t pretend...
    </summary>
    <content type="html">
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Following the &lt;a href=&quot;http://in.relation.to/2011/09/27/so-whats-happening-with-seam/&quot; target=&quot;_blank&quot;&gt;in.relation.to blog post&lt;/a&gt; of last tuesday,as a tech lead on one Seam Module (Seam Social),I wrote this open Letter to Red Hat employees in charge of Seam project and community. I find useful to share my point of view with the community on this matter. You also might find interesting to read the &lt;a href=&quot;https://hannelita.wordpress.com/2011/09/28/seam-3-whats-going-on/&quot; target=&quot;_blank&quot;&gt;blog post of Hannelita&lt;/a&gt; on the same subject.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Here is my letter:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;quoteblock&quot;&gt;
      &lt;blockquote&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This email is a tentative to gather and synthesize all my thought following the yesterday announce on in.relation.to about Seam 3 reorganization. I want it to be seen as a positive feedback. I don’t pretend to have all the answers but being someone external to Red Hat and having worked with other frameworks / technologies give me (I think) a better « big picture »view and a more objective perception of the matter.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== Who’s talking ?&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;I’m not going to tell you all my life here. But it can help for my legitimacy to know that I graduated from a famous IT School in 1995 (yes I’m 40) and had been working in IT since then. I started with C / C++ and then Lotus Domino (talking about mistakes). I started looking into Java in 1997 as a hobby and more seriously for work in 2001. I worked with a lot of Java frameworks:pure servlet and JSP,Struts 1.X,iBatis,Spring,JSF,Hibernate,EJB3,Seam 2 (I started with 2 beta in 2007) to finally adopt Java EE 6.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;I’d been working alone for 10 years then after that as a CTO in a small Web Agency (where I learnt some web marketing) and I’ve bee working since 2009 as a consultant in an IT Consulting company specialized on Java. My Job is to audit applications,design new application as an architect and doing support to other developer on a bunch of technologies.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== History (knowing our « opponent »)&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Again,I’m not going to write a novel here but I think it’s better to put things in perspective.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;JCP had clearly a bad start. Most of specification in J2EE before Java EE 5 were full of flaws (especially EJB 1.X and 2.X). That’s mainly the reason why Spring was created and has been so successful:it was a pragmatic and rather clean way to address Java Enterprise needs. From a lightweight solution spring grown to a heavy but quite consistent eco-system and today it has a big market share in the Java Industry. Meanwhile spring was getting bigger,the JCP somehow took notice of its past errors and worked to change things and provide nice specification for the new Java EE edition. But we had to wait for Java EE 6 to get an official standard that was able to compete with Spring (the de Facto Standard) thanks to CDI and the tremendous work that JBoss guys put in it.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;So today we are in a paradoxical situation where the official Java EE stack is the challenger of the de facto standard:Spring. To be honest,Java EE is better than core Spring but not way better. Also Spring has a lot of popular modules that help developers in their daily work (a big eco-system). A lot of company have invested on Spring (training,support,etc…) and they have no obvious reason to switch to Java EE 6. If we want to bring them to this switch we have to build something better and something bigger&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== What should be Red Hat goals ?&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The main goal for Red Hat is to sell licenses and support. I don’t know your exact income on JBoss activity but with a real big Java EE adoption,those incomes should rise very clearly. Right now most of the JBoss EAP server I see at my customer run Spring application and most of these server could be switched to Tomcat or Jetty tomorrow without any big trouble (the same for most WAS or Weblogic).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A secondary goal (that interest me more) is philosophical. The Java EE 6 stack is a community creation,its blue print doesn’t belong to a single shop and tomorrow if someone want to propose something new he could contribute to this community. Ok,it’s not perfect but for me it’s far way better than having VMWare deciding what’s good and wrong for me. I often say to Spring Fanboys that if they want to have one editor to decide for them they’d better switch to .Net:Microsoft does a better Job than VMWare and C# is better than Java :-) . The advantage of Java eco-system is the community. So the Goal is to use the force of this community and bring open solutions to them.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Creating a big and good CDI eco-system will create value,bring real competition to the Java stack and create more business for Red Hat (AS license or support on main CDI components)&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== Why CDI is so special&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI is not a spec among others. It’s the long awaited cement in Java EE stack. It could have been an extension of EJB spec but it was clever to create it as a separate spec and allow it to deal with EJBs. CDI is the first Java EE spec that contains in its DNA a natural extension mechanism. And last but not least CDI is probably the first Java EE spec to be usable in its V 1.0 (perhaps with Jax-RS).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;A common critic to Java EE is that it has a very long cycle between each iteration and that it delivers outdated specs. Another common critic is that it provides a bunch of specs that doesn’t work well together.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;This second critic was addressed by Seam 2. Seam was a big help to make Java EE 5 easy to use,but as you know it was proprietary.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;CDI address both critics:it has the potential to provide the same services than Seam 2 and it is a good way to extend Java EE between two versions.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;To sum up CDI is a central spec for Java EE (it’s its spine):&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;olist arabic&quot;&gt;
      &lt;ol class=&quot;arabic&quot;&gt;
      &lt;li&gt;
      &lt;p&gt;CDI is the cement between main Java EE spec&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;CDI the « melting pot »engine for adding new spec in Java EE. First in a proprietary approach and then by standardization in next EE version.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;For extension that can’t be integrated in Java EE (like Seam social) it’s an elegant and seamless way to enhance the stack.
      Past and present Errors&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ol&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== Error 1: A bad name&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;The first error in my opinion was to call it « Seam 3 ». This bad choice triggered these pb:&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;giving the impression that Seam 3 was an evolution of Seam 2. Which it is not.
      creating the obligation to build a compatibility module from Seam 2 to Seam 3. This module is costing a lot of energy to the community and will only produce deception
      Hiding the CDI nature of these extensions by calling them after the name of an « old »JBoss proprietary framework
      What is done is done,Seam 3 is now among us,but the legacy is heavy…&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== Error 2: pretending Spring doesn’t exist&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Ignore existing market is a big mistake. Spring is well implanted and doing as if it wasn’t there is wrong. I think a better way would be to adopt the following philosophy:« We know that you had to use this proprietary framework because there was nothing else but now we will show you something new,better,but &lt;strong&gt;that can use your Spring&lt;/strong&gt; eco-system ». Yes the &lt;strong&gt;Spring bridge&lt;/strong&gt; is not an option,It’s a priority. You have to help people switching by giving them a way to use their Spring components so they don’t feel lost and can use Spring module until Seam has the equivalent functionality.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Spring team is totally ignoring Java EE. Their ref doc is full of J2EE,EJB 2.1 and nothing about CDI or EJB 3. We have to show the Java community that we’re more open than them and care about people using Spring to come,see and perhaps adopt the standard. The idea is to behave at the opposite of the locking VMWare strategy by being opened and avoiding trolls and misinformation like they do.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== Error 3: eating our own dog food with Seam university.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Don’t get me wrong: the idea of Seam University website is great. What is not so great is to use our tool to create the site. We don’t have time to build something neat,so it’ll be crappy and we’ll lost time on it. Result:bad impression and time wasted. Other Framework don’t use themselves to create their website,they use standard tools. We should do the same for the Seam website. People are waiting for simple demo and example not a big steam machine like the Seam Wiki is today.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== Error 4: mix internal functioning with facade functioning of the project&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Having Seam module created near their mother project (Hibernate,Resteasy…) is not a bad idea. The bad idea is to make them disappear from the Seam stack. You can have CDI-persistence (note I didn’t wrote CDI-Hibernate) driven by Hibernate project ,but it should be visible in both Seam stack and hibernate. Because One can discover it while using Hibernate or while looking for a persistent CDI extension.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== Error 5: giving the impression that those modules will have adherence to Jboss implementation&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Calling the module Hibernate-CDI or RestEasy-CDI is a big step back (even if you keep portability). Tomorrow developers on WAS or Glassfish won’t choose them because it doesn’t support JPA but hibernate (it’s in the name). A non sense after all the effort that Jboss has injected in working on standard.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;It’s important that Seam appear as collection of CDI extension that allow to leverage standard Java EE. Having them under one umbrella allow Red Hat to sell optional support for them if people want to use them on WAS,Glassfish,Tomcat or Resin.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;== What should Seam 3 be (according to me)&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Seam should be turned to the community. I don’t know if Red Hat would be ok to do that but the core project should be outside of JBoss and community driven. It would be the best solution to gather our effort with those of CDI Source,Codi,Caucho and others.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Seam 3 should run on all CDI implementation. That’s a priority (today,Solder doesn’t work on Candi,I didn’t tested on Open WebBeans but I guess there are issues).&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Seam should provide light modules with good documentation and example. I mention that because i have he impression that Solder is becoming a kind of trash can. It’s not good. On the other way the split between persistence and transaction was a good move in my opinion&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Seam should have a clear roadmap and timeline. We have to communicate,communicate and communicate. Don’t forget that we have to convince people using an equivalent solution. We must show why we are better and that we have a clear Goal.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Thanks for your time reading my long mail. I hope it’ll be useful and I’m ready to contribute to these orientation.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;regards,&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;Antoine&lt;/p&gt;
      &lt;/div&gt;
      &lt;/blockquote&gt;
      &lt;/div&gt;
      &lt;div class=&quot;paragraph&quot;&gt;
      &lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;: Shane Bryzak project leader on Seam 3 posted an &lt;a href=&quot;http://in.relation.to/Bloggers/SeamNextUpdate&quot; target=&quot;_blank&quot;&gt;update&lt;/a&gt; this morning,to explain there is something in preparation around Seam.&lt;/p&gt;
      &lt;/div&gt;
    </content>
  </entry>
</feed>
