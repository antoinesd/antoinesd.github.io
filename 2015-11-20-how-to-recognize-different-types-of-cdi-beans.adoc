---
title: "How to recognize different types of beans from quite a long way away "
summary: CDI
layout: post
authors: [asd]
tags: [CDI,Beans,EJB]
---

= How to recognize different types of beans from quite a long way away

In CDI, Beans are a very centric concept.
Yet, for a lot of user, this concept stays fuzzy and requires experiment to achieve an expected result.
In this article I'll try to clarify most of bean related concepts and detail the hidden mechanism behind bean definition and injection.

== Bean, Bean instance and typesafe resolution

When most CDI users write

[source]
----
@Inject
@MyQualifier
MyBean bean;
----

they think: "I have injected the `MyBean` bean having `@MyQualifier` qualifier".

That's not exact and it's important to understand the exact mechanism behind this injection point definition.

=== Bean vs Bean instances

One of the specific feature in CDI is the fact that all components (qualifiers, beans, producers, etc..) are discovered at deployment time.

It allows the container to raise errors very early (before runtime) and for you to be sure that all injection points you defined will be satisfied and not ambiguous.

While this discovery process is not the topic of this article you should know that all classes packaged with your application will be analyzed at deployment to discover beans (and other components).

At the end of this discovery task, the container had created collections of meta-data for most elements included in CDI SPI.
The more centric meta-data created by CDI container is the collection of `Bean<T>` discovered during deployment.
These metadata are the real applications _beans_ and in basic CDI usage you'll never use them.

So don't mix _beans_ and the _beans instances_ you request to the container when adding an injection point in your code.

When you use `@Inject` in your code, you're asking the container to provide you an instance of a bean having the given type in its typeset and qualifiers in its qualifiers set (this process is called the http://docs.jboss.org/cdi/spec/1.2/cdi-spec.html#typesafe_resolution[_Typesafe resolution_])

=== Bean Metadata

.Bean Interface hierarchy, yes Interceptor and Decorator are also Beans
[plantuml, bean-hierarchy, svg]
....
@startuml

skinparam shadowing false
skinparam defaultFontName Consolas

BeanAttributes <|-- Bean
Bean <|-- Interceptor
Bean <|-- Decorator



interface BeanAttributes<T> {
    +Set<Type> getTypes()
    +Set<Annotation> getQualifiers()
    +Class<? extends Annotation> getScope()
    +String getName()
    +Set<Class<? extends Annotation>> getStereotypes()
    +boolean isAlternative()
}


interface Bean<T> {
    +Class<?> getBeanClass()
    +Set<InjectionPoint> getInjectionPoints()
    +boolean isNullable()
}


interface Interceptor<T> {
    +Set<Annotation> getInterceptorBindings()
    +boolean intercepts(InterceptionType type)
    +Object intercept(InterceptionType, T, InvocationContext)
}

interface Decorator<T> {
    +Type getDelegateType()
    +Set<Annotation> getDelegateQualifiers()
    +Set<Type> getDecoratedTypes()
}


@enduml
....

=== So when do we refer to the `Bean<T>`?

In basic CDI, the answer is "never" (or almost).

`Bean<T>` will be used 90% of the time in portable extension to observer meta data for create a custom bean or analyse bean metadata.

Since CDI 1.1 you can also use `Bean<T>` outside extensions.

For the sake of reflection it is now allowed to inject the bean meta-data in a bean class, an interceptor or a decorator, allowing them to have info on metadata of the current bean.

For instance thsi interceptor use the meta-data of the intercepted bean to avoid issue with proxy creation in the implementation:

[source]
----
@Loggable
@Interceptor
public class LoggingInterceptor {

    @Inject
    private Logger logger;

    @Inject @Intercepted //<1>
    private Bean<?> intercepted;

    @AroundInvoke
    private Object intercept(InvocationContext ic) throws Exception {
        logger.info(">> " + intercepted.getBeanClass().getName() + " - " + ic.getMethod().getName()); //<2>
        try {
            return ic.proceed();
        } finally {
            logger.info("<< " + intercepted.getBeanClass().getName() + " - " + ic.getMethod().getName());
        }
    }
}
----
<1> `@Intercepted` is a reserved qualifier to inject the intercepted bean in an interceptor
<2> here it is used to retrieve the actual class of the bean instance not the proxy's class implementation may have created




== CDI different kinds of beans

Now that we stated the difference between Bean and Bean instances, it's time to list all the bean kind we've got in CDI and their specific behaviour.

=== Managed beans



=== Session beans

=== Producers

=== Resources

=== Built-in beans

=== Custom beans

// example bean that keep track of it's instances
